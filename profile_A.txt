*** File /usr/include/boost/random/detail/signed_unsigned_tools.hpp:
                /* boost random/detail/signed_unsigned_tools.hpp header file
                 *
                 * Copyright Jens Maurer 2006
                 * Distributed under the Boost Software License, Version 1.0. (See
                 * accompanying file LICENSE_1_0.txt or copy at
                 * http://www.boost.org/LICENSE_1_0.txt)
                 *
                 * See http://www.boost.org for most recent version including documentation.
                 */
                
                #ifndef BOOST_RANDOM_DETAIL_SIGNED_UNSIGNED_TOOLS
                #define BOOST_RANDOM_DETAIL_SIGNED_UNSIGNED_TOOLS
                
                #include <boost/limits.hpp>
                #include <boost/config.hpp>
                #include <boost/type_traits/make_unsigned.hpp>
                
                namespace boost {
                namespace random {
                namespace detail {
                
                
                /*
                 * Compute x - y, we know that x >= y, return an unsigned value.
                 */
                
                template<class T, bool sgn = std::numeric_limits<T>::is_signed>
                struct subtract { };
                
                template<class T>
                struct subtract<T, /* signed */ false>
                {
                  typedef T result_type;
       48000 ->   result_type operator()(T x, T y) { return x - y; }
                };
                
                template<class T>
                struct subtract<T, /* signed */ true>
                {
                  typedef typename make_unsigned<T>::type result_type;
                  result_type operator()(T x, T y)
                  {
                    if (y >= 0)   // because x >= y, it follows that x >= 0, too
                      return result_type(x) - result_type(y);
                    if (x >= 0)   // y < 0
                      // avoid the nasty two's complement case for y == min()
                      return result_type(x) + result_type(-(y+1)) + 1;
                    // both x and y are negative: no signed overflow
                    return result_type(x - y);
                  }
                };
                
                /*
                 * Compute x + y, x is unsigned, result fits in type of "y".
                 */
                
                template<class T1, class T2, bool sgn = std::numeric_limits<T2>::is_signed>
                struct add { };
                
                template<class T1, class T2>
                struct add<T1, T2, /* signed */ false>
                {
                  typedef T2 result_type;
                  result_type operator()(T1 x, T2 y) { return T2(x) + y; }
                };
                
                template<class T1, class T2>
                struct add<T1, T2, /* signed */ true>
                {
                  typedef T2 result_type;
                  result_type operator()(T1 x, T2 y)
                  {
                    if (y >= 0)
                      return T2(x) + y;
                    // y < 0
                    if (x > T1(-(y+1)))  // result >= 0 after subtraction
                      // avoid the nasty two's complement edge case for y == min()
                      return T2(x - T1(-(y+1)) - 1);
                    // abs(x) < abs(y), thus T2 able to represent x
                    return T2(x) + y;
                  }
                };
                
                } // namespace detail
                } // namespace random
                } // namespace boost
                
                #endif // BOOST_RANDOM_DETAIL_SIGNED_UNSIGNED_TOOLS
                


Top 10 Lines:

     Line      Count

       34      48000

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    48000   Total number of line executions
 48000.00   Average executions per line


*** File /usr/include/boost/math/tools/rational.hpp:
                //  (C) Copyright John Maddock 2006.
                //  Use, modification and distribution are subject to the
                //  Boost Software License, Version 1.0. (See accompanying file
                //  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
                
                #ifndef BOOST_MATH_TOOLS_RATIONAL_HPP
                #define BOOST_MATH_TOOLS_RATIONAL_HPP
                
                #ifdef _MSC_VER
                #pragma once
                #endif
                
                #include <boost/array.hpp>
                #include <boost/math/tools/config.hpp>
                #include <boost/mpl/int.hpp>
                
                #if BOOST_MATH_POLY_METHOD == 1
                #  define BOOST_HEADER() <BOOST_JOIN(boost/math/tools/detail/polynomial_horner1_, BOOST_MATH_MAX_POLY_ORDER).hpp>
                #  include BOOST_HEADER()
                #  undef BOOST_HEADER
                #elif BOOST_MATH_POLY_METHOD == 2
                #  define BOOST_HEADER() <BOOST_JOIN(boost/math/tools/detail/polynomial_horner2_, BOOST_MATH_MAX_POLY_ORDER).hpp>
                #  include BOOST_HEADER()
                #  undef BOOST_HEADER
                #elif BOOST_MATH_POLY_METHOD == 3
                #  define BOOST_HEADER() <BOOST_JOIN(boost/math/tools/detail/polynomial_horner3_, BOOST_MATH_MAX_POLY_ORDER).hpp>
                #  include BOOST_HEADER()
                #  undef BOOST_HEADER
                #endif
                #if BOOST_MATH_RATIONAL_METHOD == 1
                #  define BOOST_HEADER() <BOOST_JOIN(boost/math/tools/detail/rational_horner1_, BOOST_MATH_MAX_POLY_ORDER).hpp>
                #  include BOOST_HEADER()
                #  undef BOOST_HEADER
                #elif BOOST_MATH_RATIONAL_METHOD == 2
                #  define BOOST_HEADER() <BOOST_JOIN(boost/math/tools/detail/rational_horner2_, BOOST_MATH_MAX_POLY_ORDER).hpp>
                #  include BOOST_HEADER()
                #  undef BOOST_HEADER
                #elif BOOST_MATH_RATIONAL_METHOD == 3
                #  define BOOST_HEADER() <BOOST_JOIN(boost/math/tools/detail/rational_horner3_, BOOST_MATH_MAX_POLY_ORDER).hpp>
                #  include BOOST_HEADER()
                #  undef BOOST_HEADER
                #endif
                
                #if 0
                //
                // This just allows dependency trackers to find the headers
                // used in the above PP-magic.
                //
                #include <boost/math/tools/detail/polynomial_horner1_2.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_3.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_4.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_5.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_6.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_7.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_8.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_9.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_10.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_11.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_12.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_13.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_14.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_15.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_16.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_17.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_18.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_19.hpp>
                #include <boost/math/tools/detail/polynomial_horner1_20.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_2.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_3.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_4.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_5.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_6.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_7.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_8.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_9.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_10.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_11.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_12.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_13.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_14.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_15.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_16.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_17.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_18.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_19.hpp>
                #include <boost/math/tools/detail/polynomial_horner2_20.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_2.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_3.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_4.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_5.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_6.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_7.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_8.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_9.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_10.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_11.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_12.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_13.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_14.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_15.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_16.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_17.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_18.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_19.hpp>
                #include <boost/math/tools/detail/polynomial_horner3_20.hpp>
                #include <boost/math/tools/detail/rational_horner1_2.hpp>
                #include <boost/math/tools/detail/rational_horner1_3.hpp>
                #include <boost/math/tools/detail/rational_horner1_4.hpp>
                #include <boost/math/tools/detail/rational_horner1_5.hpp>
                #include <boost/math/tools/detail/rational_horner1_6.hpp>
                #include <boost/math/tools/detail/rational_horner1_7.hpp>
                #include <boost/math/tools/detail/rational_horner1_8.hpp>
                #include <boost/math/tools/detail/rational_horner1_9.hpp>
                #include <boost/math/tools/detail/rational_horner1_10.hpp>
                #include <boost/math/tools/detail/rational_horner1_11.hpp>
                #include <boost/math/tools/detail/rational_horner1_12.hpp>
                #include <boost/math/tools/detail/rational_horner1_13.hpp>
                #include <boost/math/tools/detail/rational_horner1_14.hpp>
                #include <boost/math/tools/detail/rational_horner1_15.hpp>
                #include <boost/math/tools/detail/rational_horner1_16.hpp>
                #include <boost/math/tools/detail/rational_horner1_17.hpp>
                #include <boost/math/tools/detail/rational_horner1_18.hpp>
                #include <boost/math/tools/detail/rational_horner1_19.hpp>
                #include <boost/math/tools/detail/rational_horner1_20.hpp>
                #include <boost/math/tools/detail/rational_horner2_2.hpp>
                #include <boost/math/tools/detail/rational_horner2_3.hpp>
                #include <boost/math/tools/detail/rational_horner2_4.hpp>
                #include <boost/math/tools/detail/rational_horner2_5.hpp>
                #include <boost/math/tools/detail/rational_horner2_6.hpp>
                #include <boost/math/tools/detail/rational_horner2_7.hpp>
                #include <boost/math/tools/detail/rational_horner2_8.hpp>
                #include <boost/math/tools/detail/rational_horner2_9.hpp>
                #include <boost/math/tools/detail/rational_horner2_10.hpp>
                #include <boost/math/tools/detail/rational_horner2_11.hpp>
                #include <boost/math/tools/detail/rational_horner2_12.hpp>
                #include <boost/math/tools/detail/rational_horner2_13.hpp>
                #include <boost/math/tools/detail/rational_horner2_14.hpp>
                #include <boost/math/tools/detail/rational_horner2_15.hpp>
                #include <boost/math/tools/detail/rational_horner2_16.hpp>
                #include <boost/math/tools/detail/rational_horner2_17.hpp>
                #include <boost/math/tools/detail/rational_horner2_18.hpp>
                #include <boost/math/tools/detail/rational_horner2_19.hpp>
                #include <boost/math/tools/detail/rational_horner2_20.hpp>
                #include <boost/math/tools/detail/rational_horner3_2.hpp>
                #include <boost/math/tools/detail/rational_horner3_3.hpp>
                #include <boost/math/tools/detail/rational_horner3_4.hpp>
                #include <boost/math/tools/detail/rational_horner3_5.hpp>
                #include <boost/math/tools/detail/rational_horner3_6.hpp>
                #include <boost/math/tools/detail/rational_horner3_7.hpp>
                #include <boost/math/tools/detail/rational_horner3_8.hpp>
                #include <boost/math/tools/detail/rational_horner3_9.hpp>
                #include <boost/math/tools/detail/rational_horner3_10.hpp>
                #include <boost/math/tools/detail/rational_horner3_11.hpp>
                #include <boost/math/tools/detail/rational_horner3_12.hpp>
                #include <boost/math/tools/detail/rational_horner3_13.hpp>
                #include <boost/math/tools/detail/rational_horner3_14.hpp>
                #include <boost/math/tools/detail/rational_horner3_15.hpp>
                #include <boost/math/tools/detail/rational_horner3_16.hpp>
                #include <boost/math/tools/detail/rational_horner3_17.hpp>
                #include <boost/math/tools/detail/rational_horner3_18.hpp>
                #include <boost/math/tools/detail/rational_horner3_19.hpp>
                #include <boost/math/tools/detail/rational_horner3_20.hpp>
                #endif
                
                namespace boost{ namespace math{ namespace tools{
                
                //
                // Forward declaration to keep two phase lookup happy:
                //
                template <class T, class U>
                U evaluate_polynomial(const T* poly, U const& z, std::size_t count);
                
                namespace detail{
                
                template <class T, class V, class Tag>
                inline V evaluate_polynomial_c_imp(const T* a, const V& val, const Tag*)
                {
                   return evaluate_polynomial(a, val, Tag::value);
                }
                
                } // namespace detail
                
                //
                // Polynomial evaluation with runtime size.
                // This requires a for-loop which may be more expensive than
                // the loop expanded versions above:
                //
                template <class T, class U>
                inline U evaluate_polynomial(const T* poly, U const& z, std::size_t count)
                {
                   BOOST_ASSERT(count > 0);
                   U sum = static_cast<U>(poly[count - 1]);
                   for(int i = static_cast<int>(count) - 2; i >= 0; --i)
                   {
                      sum *= z;
                      sum += static_cast<U>(poly[i]);
                   }
                   return sum;
                }
                //
                // Compile time sized polynomials, just inline forwarders to the
                // implementations above:
                //
                template <std::size_t N, class T, class V>
                inline V evaluate_polynomial(const T(&a)[N], const V& val)
                {
                   typedef mpl::int_<N> tag_type;
                   return detail::evaluate_polynomial_c_imp(static_cast<const T*>(a), val, static_cast<tag_type const*>(0));
                }
                
                template <std::size_t N, class T, class V>
                inline V evaluate_polynomial(const boost::array<T,N>& a, const V& val)
                {
                   typedef mpl::int_<N> tag_type;
                   return detail::evaluate_polynomial_c_imp(static_cast<const T*>(a.data()), val, static_cast<tag_type const*>(0));
                }
                //
                // Even polynomials are trivial: just square the argument!
                //
                template <class T, class U>
                inline U evaluate_even_polynomial(const T* poly, U z, std::size_t count)
                {
                   return evaluate_polynomial(poly, U(z*z), count);
                }
                
                template <std::size_t N, class T, class V>
                inline V evaluate_even_polynomial(const T(&a)[N], const V& z)
                {
                   return evaluate_polynomial(a, V(z*z));
                }
                
                template <std::size_t N, class T, class V>
                inline V evaluate_even_polynomial(const boost::array<T,N>& a, const V& z)
                {
                   return evaluate_polynomial(a, V(z*z));
                }
                //
                // Odd polynomials come next:
                //
                template <class T, class U>
                inline U evaluate_odd_polynomial(const T* poly, U z, std::size_t count)
                {
                   return poly[0] + z * evaluate_polynomial(poly+1, U(z*z), count-1);
                }
                
                template <std::size_t N, class T, class V>
                inline V evaluate_odd_polynomial(const T(&a)[N], const V& z)
                {
                   typedef mpl::int_<N-1> tag_type;
                   return a[0] + z * detail::evaluate_polynomial_c_imp(static_cast<const T*>(a) + 1, V(z*z), static_cast<tag_type const*>(0));
                }
                
                template <std::size_t N, class T, class V>
                inline V evaluate_odd_polynomial(const boost::array<T,N>& a, const V& z)
                {
                   typedef mpl::int_<N-1> tag_type;
                   return a[0] + z * detail::evaluate_polynomial_c_imp(static_cast<const T*>(a.data()) + 1, V(z*z), static_cast<tag_type const*>(0));
                }
                
                template <class T, class U, class V>
                V evaluate_rational(const T* num, const U* denom, const V& z_, std::size_t count);
                
                namespace detail{
                
                template <class T, class U, class V, class Tag>
                inline V evaluate_rational_c_imp(const T* num, const U* denom, const V& z, const Tag*)
                {
                   return boost::math::tools::evaluate_rational(num, denom, z, Tag::value);
                }
                
                }
                //
                // Rational functions: numerator and denominator must be
                // equal in size.  These always have a for-loop and so may be less
                // efficient than evaluating a pair of polynomials. However, there
                // are some tricks we can use to prevent overflow that might otherwise
                // occur in polynomial evaluation, if z is large.  This is important
                // in our Lanczos code for example.
                //
                template <class T, class U, class V>
                V evaluate_rational(const T* num, const U* denom, const V& z_, std::size_t count)
                {
                   V z(z_);
                   V s1, s2;
                   if(z <= 1)
                   {
                      s1 = static_cast<V>(num[count-1]);
                      s2 = static_cast<V>(denom[count-1]);
                      for(int i = (int)count - 2; i >= 0; --i)
                      {
                         s1 *= z;
                         s2 *= z;
                         s1 += num[i];
                         s2 += denom[i];
                      }
                   }
                   else
                   {
                      z = 1 / z;
                      s1 = static_cast<V>(num[0]);
                      s2 = static_cast<V>(denom[0]);
                      for(unsigned i = 1; i < count; ++i)
                      {
                         s1 *= z;
                         s2 *= z;
                         s1 += num[i];
                         s2 += denom[i];
                      }
                   }
                   return s1 / s2;
                }
                
                template <std::size_t N, class T, class U, class V>
           2 -> inline V evaluate_rational(const T(&a)[N], const U(&b)[N], const V& z)
                {
                   return detail::evaluate_rational_c_imp(a, b, z, static_cast<const mpl::int_<N>*>(0));
                }
                
                template <std::size_t N, class T, class U, class V>
                inline V evaluate_rational(const boost::array<T,N>& a, const boost::array<U,N>& b, const V& z)
                {
                   return detail::evaluate_rational_c_imp(a.data(), b.data(), z, static_cast<mpl::int_<N>*>(0));
                }
                
                } // namespace tools
                } // namespace math
                } // namespace boost
                
                #endif // BOOST_MATH_TOOLS_RATIONAL_HPP
                
                
                
                


Top 10 Lines:

     Line      Count

      314          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File /usr/include/boost/math/tools/big_constant.hpp:
                
                //  Copyright (c) 2011 John Maddock
                //  Use, modification and distribution are subject to the
                //  Boost Software License, Version 1.0. (See accompanying file
                //  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
                
                #ifndef BOOST_MATH_TOOLS_BIG_CONSTANT_HPP
                #define BOOST_MATH_TOOLS_BIG_CONSTANT_HPP
                
                #include <boost/math/tools/config.hpp>
                #ifndef BOOST_MATH_NO_LEXICAL_CAST
                #include <boost/lexical_cast.hpp>
                #endif
                #include <boost/type_traits/is_convertible.hpp>
                
                namespace boost{ namespace math{ 
                
                namespace tools{
                
                template <class T>
          66 -> inline BOOST_CONSTEXPR_OR_CONST T make_big_value(long double v, const char*, mpl::true_ const&, mpl::false_ const&)
                {
                   return static_cast<T>(v);
                }
                template <class T>
                inline BOOST_CONSTEXPR_OR_CONST T make_big_value(long double v, const char*, mpl::true_ const&, mpl::true_ const&)
                {
                   return static_cast<T>(v);
                }
                #ifndef BOOST_MATH_NO_LEXICAL_CAST
                template <class T>
                inline T make_big_value(long double, const char* s, mpl::false_ const&, mpl::false_ const&)
                {
                   return boost::lexical_cast<T>(s);
                }
                #endif
                template <class T>
                inline BOOST_CONSTEXPR const char* make_big_value(long double, const char* s, mpl::false_ const&, mpl::true_ const&)
                {
                   return s;
                }
                
                //
                // For constants which might fit in a long double (if it's big enough):
                //
                #define BOOST_MATH_BIG_CONSTANT(T, D, x)\
                   boost::math::tools::make_big_value<T>(\
                      BOOST_JOIN(x, L), \
                      BOOST_STRINGIZE(x), \
                      mpl::bool_< (is_convertible<long double, T>::value) && \
                         ((D <= std::numeric_limits<long double>::digits) \
                          || is_floating_point<T>::value \
                          || (std::numeric_limits<T>::is_specialized && \
                             (std::numeric_limits<T>::digits10 <= std::numeric_limits<long double>::digits10))) >(), \
                      boost::is_convertible<const char*, T>())
                //
                // For constants too huge for any conceivable long double (and which generate compiler errors if we try and declare them as such):
                //
                #define BOOST_MATH_HUGE_CONSTANT(T, D, x)\
                   boost::math::tools::make_big_value<T>(0.0L, BOOST_STRINGIZE(x), mpl::bool_<is_floating_point<T>::value || (std::numeric_limits<T>::is_specialized && std::numeric_limits<T>::max_exponent <= std::numeric_limits<long double>::max_exponent)>(), boost::is_convertible<const char*, T>())
                
                }}} // namespaces
                
                #endif
                


Top 10 Lines:

     Line      Count

       21         66

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

       66   Total number of line executions
    66.00   Average executions per line


*** File /usr/include/c++/4.8/limits:
                // The template and inlines for the numeric_limits classes. -*- C++ -*-
                
                // Copyright (C) 1999-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/limits
                 *  This is a Standard C++ Library header.
                 */
                
                // Note: this is not a conforming implementation.
                // Written by Gabriel Dos Reis <gdr@codesourcery.com>
                
                //
                // ISO 14882:1998
                // 18.2.1
                //
                
                #ifndef _GLIBCXX_NUMERIC_LIMITS
                #define _GLIBCXX_NUMERIC_LIMITS 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                //
                // The numeric_limits<> traits document implementation-defined aspects
                // of fundamental arithmetic data types (integers and floating points).
                // From Standard C++ point of view, there are 14 such types:
                //   * integers
                //         bool							(1)
                //         char, signed char, unsigned char, wchar_t            (4)
                //         short, unsigned short				(2)
                //         int, unsigned					(2)
                //         long, unsigned long					(2)
                //
                //   * floating points
                //         float						(1)
                //         double						(1)
                //         long double						(1)
                //
                // GNU C++ understands (where supported by the host C-library)
                //   * integer
                //         long long, unsigned long long			(2)
                //
                // which brings us to 16 fundamental arithmetic data types in GNU C++.
                //
                //
                // Since a numeric_limits<> is a bit tricky to get right, we rely on
                // an interface composed of macros which should be defined in config/os
                // or config/cpu when they differ from the generic (read arbitrary)
                // definitions given here.
                //
                
                // These values can be overridden in the target configuration file.
                // The default values are appropriate for many 32-bit targets.
                
                // GCC only intrinsically supports modulo integral types.  The only remaining
                // integral exceptional values is division by zero.  Only targets that do not
                // signal division by zero in some "hard to ignore" way should use false.
                #ifndef __glibcxx_integral_traps
                # define __glibcxx_integral_traps true
                #endif
                
                // float
                //
                
                // Default values.  Should be overridden in configuration files if necessary.
                
                #ifndef __glibcxx_float_has_denorm_loss
                #  define __glibcxx_float_has_denorm_loss false
                #endif
                #ifndef __glibcxx_float_traps
                #  define __glibcxx_float_traps false
                #endif
                #ifndef __glibcxx_float_tinyness_before
                #  define __glibcxx_float_tinyness_before false
                #endif
                
                // double
                
                // Default values.  Should be overridden in configuration files if necessary.
                
                #ifndef __glibcxx_double_has_denorm_loss
                #  define __glibcxx_double_has_denorm_loss false
                #endif
                #ifndef __glibcxx_double_traps
                #  define __glibcxx_double_traps false
                #endif
                #ifndef __glibcxx_double_tinyness_before
                #  define __glibcxx_double_tinyness_before false
                #endif
                
                // long double
                
                // Default values.  Should be overridden in configuration files if necessary.
                
                #ifndef __glibcxx_long_double_has_denorm_loss
                #  define __glibcxx_long_double_has_denorm_loss false
                #endif
                #ifndef __glibcxx_long_double_traps
                #  define __glibcxx_long_double_traps false
                #endif
                #ifndef __glibcxx_long_double_tinyness_before
                #  define __glibcxx_long_double_tinyness_before false
                #endif
                
                // You should not need to define any macros below this point.
                
                #define __glibcxx_signed(T)	((T)(-1) < 0)
                
                #define __glibcxx_min(T) \
                  (__glibcxx_signed (T) ? -__glibcxx_max (T) - 1 : (T)0)
                
                #define __glibcxx_max(T) \
                  (__glibcxx_signed (T) ? \
                   (((((T)1 << (__glibcxx_digits (T) - 1)) - 1) << 1) + 1) : ~(T)0)
                
                #define __glibcxx_digits(T) \
                  (sizeof(T) * __CHAR_BIT__ - __glibcxx_signed (T))
                
                // The fraction 643/2136 approximates log10(2) to 7 significant digits.
                #define __glibcxx_digits10(T) \
                  (__glibcxx_digits (T) * 643L / 2136)
                
                #define __glibcxx_max_digits10(T) \
                  (2 + (T) * 643L / 2136)
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @brief Describes the rounding style for floating-point types.
                   *
                   *  This is used in the std::numeric_limits class.
                  */
                  enum float_round_style
                  {
                    round_indeterminate       = -1,    /// Intermediate.
                    round_toward_zero         = 0,     /// To zero.
                    round_to_nearest          = 1,     /// To the nearest representable value.
                    round_toward_infinity     = 2,     /// To infinity.
                    round_toward_neg_infinity = 3      /// To negative infinity.
                  };
                
                  /**
                   *  @brief Describes the denormalization for floating-point types.
                   *
                   *  These values represent the presence or absence of a variable number
                   *  of exponent bits.  This type is used in the std::numeric_limits class.
                  */
                  enum float_denorm_style
                  {
                    /// Indeterminate at compile time whether denormalized values are allowed.
                    denorm_indeterminate = -1,
                    /// The type does not allow denormalized values.
                    denorm_absent        = 0,
                    /// The type allows denormalized values.
                    denorm_present       = 1
                  };
                
                  /**
                   *  @brief Part of std::numeric_limits.
                   *
                   *  The @c static @c const members are usable as integral constant
                   *  expressions.
                   *
                   *  @note This is a separate class for purposes of efficiency; you
                   *        should only access these members as part of an instantiation
                   *        of the std::numeric_limits class.
                  */
                  struct __numeric_limits_base
                  {
                    /** This will be true for all fundamental types (which have
                	specializations), and false for everything else.  */
                    static _GLIBCXX_USE_CONSTEXPR bool is_specialized = false;
                
                    /** The number of @c radix digits that be represented without change:  for
                	integer types, the number of non-sign bits in the mantissa; for
                	floating types, the number of @c radix digits in the mantissa.  */
                    static _GLIBCXX_USE_CONSTEXPR int digits = 0;
                
                    /** The number of base 10 digits that can be represented without change. */
                    static _GLIBCXX_USE_CONSTEXPR int digits10 = 0;
                
                #if __cplusplus >= 201103L
                    /** The number of base 10 digits required to ensure that values which
                	differ are always differentiated.  */
                    static constexpr int max_digits10 = 0;
                #endif
                
                    /** True if the type is signed.  */
                    static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
                
                    /** True if the type is integer.  */
                    static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;
                
                    /** True if the type uses an exact representation. All integer types are
                	exact, but not all exact types are integer.  For example, rational and
                	fixed-exponent representations are exact but not integer. */
                    static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;
                
                    /** For integer types, specifies the base of the representation.  For
                	floating types, specifies the base of the exponent representation.  */
                    static _GLIBCXX_USE_CONSTEXPR int radix = 0;
                
                    /** The minimum negative integer such that @c radix raised to the power of
                	(one less than that integer) is a normalized floating point number.  */
                    static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                
                    /** The minimum negative integer such that 10 raised to that power is in
                	the range of normalized floating point numbers.  */
                    static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                
                    /** The maximum positive integer such that @c radix raised to the power of
                	(one less than that integer) is a representable finite floating point
                	number.  */
                    static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                
                    /** The maximum positive integer such that 10 raised to that power is in
                	the range of representable finite floating point numbers.  */
                    static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                    /** True if the type has a representation for positive infinity.  */
                    static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                
                    /** True if the type has a representation for a quiet (non-signaling)
                	Not a Number.  */
                    static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                
                    /** True if the type has a representation for a signaling
                	Not a Number.  */
                    static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                
                    /** See std::float_denorm_style for more information.  */
                    static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm = denorm_absent;
                
                    /** True if loss of accuracy is detected as a denormalization loss,
                	rather than as an inexact result. */
                    static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                    /** True if-and-only-if the type adheres to the IEC 559 standard, also
                	known as IEEE 754.  (Only makes sense for floating point types.)  */
                    static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                
                    /** True if the set of values representable by the type is
                	finite.  All built-in types are bounded, this member would be
                	false for arbitrary precision types. */
                    static _GLIBCXX_USE_CONSTEXPR bool is_bounded = false;
                
                    /** True if the type is @e modulo. A type is modulo if, for any
                	operation involving +, -, or * on values of that type whose
                	result would fall outside the range [min(),max()], the value
                	returned differs from the true value by an integer multiple of
                	max() - min() + 1. On most machines, this is false for floating
                	types, true for unsigned integers, and true for signed integers.
                	See PR22200 about signed integers.  */
                    static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                    /** True if trapping is implemented for this type.  */
                    static _GLIBCXX_USE_CONSTEXPR bool traps = false;
                
                    /** True if tininess is detected before rounding.  (see IEC 559)  */
                    static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                
                    /** See std::float_round_style for more information.  This is only
                	meaningful for floating types; integer types will all be
                	round_toward_zero.  */
                    static _GLIBCXX_USE_CONSTEXPR float_round_style round_style = 
                						    round_toward_zero;
                  };
                
                  /**
                   *  @brief Properties of fundamental types.
                   *
                   *  This class allows a program to obtain information about the
                   *  representation of a fundamental type on a given platform.  For
                   *  non-fundamental types, the functions will return 0 and the data
                   *  members will all be @c false.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS:  DRs 201 and 184 (hi Gaby!) are
                   *  noted, but not incorporated in this documented (yet).
                  */
                  template<typename _Tp>
                    struct numeric_limits : public __numeric_limits_base
                    {
                      /** The minimum finite value, or for floating types with
                	  denormalization, the minimum positive normalized value.  */
                      static _GLIBCXX_CONSTEXPR _Tp
                      min() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
                
                      /** The maximum finite value.  */
                      static _GLIBCXX_CONSTEXPR _Tp
                      max() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
                
                #if __cplusplus >= 201103L
                      /** A finite value x such that there is no other finite value y
                       *  where y < x.  */
                      static constexpr _Tp
                      lowest() noexcept { return _Tp(); }
                #endif
                
                      /** The @e machine @e epsilon:  the difference between 1 and the least
                	  value greater than 1 that is representable.  */
                      static _GLIBCXX_CONSTEXPR _Tp
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
                
                      /** The maximum rounding error measurement (see LIA-1).  */
                      static _GLIBCXX_CONSTEXPR _Tp
                      round_error() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
                
                      /** The representation of positive infinity, if @c has_infinity.  */
                      static _GLIBCXX_CONSTEXPR _Tp
                      infinity() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
                
                      /** The representation of a quiet Not a Number,
                	  if @c has_quiet_NaN. */
                      static _GLIBCXX_CONSTEXPR _Tp
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
                
                      /** The representation of a signaling Not a Number, if
                	  @c has_signaling_NaN. */
                      static _GLIBCXX_CONSTEXPR _Tp
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
                
                      /** The minimum positive denormalized value.  For types where
                	  @c has_denorm is false, this is the minimum positive normalized
                	  value.  */
                      static _GLIBCXX_CONSTEXPR _Tp
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return _Tp(); }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Tp>
                    struct numeric_limits<const _Tp>
                    : public numeric_limits<_Tp> { };
                
                  template<typename _Tp>
                    struct numeric_limits<volatile _Tp>
                    : public numeric_limits<_Tp> { };
                
                  template<typename _Tp>
                    struct numeric_limits<const volatile _Tp>
                    : public numeric_limits<_Tp> { };
                #endif
                
                  // Now there follow 16 explicit specializations.  Yes, 16.  Make sure
                  // you get the count right. (18 in c++0x mode)
                
                  /// numeric_limits<bool> specialization.
                  template<>
                    struct numeric_limits<bool>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR bool 
                      min() _GLIBCXX_USE_NOEXCEPT { return false; }
                
                      static _GLIBCXX_CONSTEXPR bool 
                      max() _GLIBCXX_USE_NOEXCEPT { return true; }
                
                #if __cplusplus >= 201103L
                      static constexpr bool
                      lowest() noexcept { return min(); }
                #endif
                      static _GLIBCXX_USE_CONSTEXPR int digits = 1;
                      static _GLIBCXX_USE_CONSTEXPR int digits10 = 0;
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR bool 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return false; }
                
                      static _GLIBCXX_CONSTEXPR bool 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return false; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR bool 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return false; }
                
                      static _GLIBCXX_CONSTEXPR bool 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return false; }
                
                      static _GLIBCXX_CONSTEXPR bool 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return false; }
                
                      static _GLIBCXX_CONSTEXPR bool 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return false; }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      // It is not clear what it means for a boolean type to trap.
                      // This is a DR on the LWG issue list.  Here, I use integer
                      // promotion semantics.
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<char> specialization.
                  template<>
                    struct numeric_limits<char>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR char 
                      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min(char); }
                
                      static _GLIBCXX_CONSTEXPR char 
                      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max(char); }
                
                #if __cplusplus >= 201103L
                      static constexpr char 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (char);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (char);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = __glibcxx_signed (char);
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR char 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR char 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR 
                      char infinity() _GLIBCXX_USE_NOEXCEPT { return char(); }
                
                      static _GLIBCXX_CONSTEXPR char 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return char(); }
                
                      static _GLIBCXX_CONSTEXPR char 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return char(); }
                
                      static _GLIBCXX_CONSTEXPR char 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<char>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = !is_signed;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<signed char> specialization.
                  template<>
                    struct numeric_limits<signed char>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR signed char 
                      min() _GLIBCXX_USE_NOEXCEPT { return -__SCHAR_MAX__ - 1; }
                
                      static _GLIBCXX_CONSTEXPR signed char 
                      max() _GLIBCXX_USE_NOEXCEPT { return __SCHAR_MAX__; }
                
                #if __cplusplus >= 201103L
                      static constexpr signed char 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (signed char);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 
                       = __glibcxx_digits10 (signed char);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR signed char 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR signed char 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR signed char 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<signed char>(0); }
                
                      static _GLIBCXX_CONSTEXPR signed char 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<signed char>(0); }
                
                      static _GLIBCXX_CONSTEXPR signed char 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<signed char>(0); }
                
                      static _GLIBCXX_CONSTEXPR signed char 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<signed char>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<unsigned char> specialization.
                  template<>
                    struct numeric_limits<unsigned char>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR unsigned char 
                      min() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned char 
                      max() _GLIBCXX_USE_NOEXCEPT { return __SCHAR_MAX__ * 2U + 1; }
                
                #if __cplusplus >= 201103L
                      static constexpr unsigned char 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits 
                       = __glibcxx_digits (unsigned char);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 
                       = __glibcxx_digits10 (unsigned char);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR unsigned char 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned char 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR unsigned char 
                      infinity() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned char>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned char 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned char>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned char 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned char>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned char 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned char>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<wchar_t> specialization.
                  template<>
                    struct numeric_limits<wchar_t>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR wchar_t 
                      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min (wchar_t); }
                
                      static _GLIBCXX_CONSTEXPR wchar_t 
                      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (wchar_t); }
                
                #if __cplusplus >= 201103L
                      static constexpr wchar_t
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (wchar_t);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 
                       = __glibcxx_digits10 (wchar_t);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = __glibcxx_signed (wchar_t);
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR wchar_t 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR wchar_t 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR wchar_t 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }
                
                      static _GLIBCXX_CONSTEXPR wchar_t 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }
                
                      static _GLIBCXX_CONSTEXPR wchar_t 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }
                
                      static _GLIBCXX_CONSTEXPR wchar_t 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return wchar_t(); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = !is_signed;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                #if __cplusplus >= 201103L
                  /// numeric_limits<char16_t> specialization.
                  template<>
                    struct numeric_limits<char16_t>
                    {
                      static constexpr bool is_specialized = true;
                
                      static constexpr char16_t 
                      min() noexcept { return __glibcxx_min (char16_t); }
                
                      static constexpr char16_t 
                      max() noexcept { return __glibcxx_max (char16_t); }
                
                      static constexpr char16_t 
                      lowest() noexcept { return min(); }
                
                      static constexpr int digits = __glibcxx_digits (char16_t);
                      static constexpr int digits10 = __glibcxx_digits10 (char16_t);
                      static constexpr int max_digits10 = 0;
                      static constexpr bool is_signed = __glibcxx_signed (char16_t);
                      static constexpr bool is_integer = true;
                      static constexpr bool is_exact = true;
                      static constexpr int radix = 2;
                
                      static constexpr char16_t 
                      epsilon() noexcept { return 0; }
                
                      static constexpr char16_t 
                      round_error() noexcept { return 0; }
                
                      static constexpr int min_exponent = 0;
                      static constexpr int min_exponent10 = 0;
                      static constexpr int max_exponent = 0;
                      static constexpr int max_exponent10 = 0;
                
                      static constexpr bool has_infinity = false;
                      static constexpr bool has_quiet_NaN = false;
                      static constexpr bool has_signaling_NaN = false;
                      static constexpr float_denorm_style has_denorm = denorm_absent;
                      static constexpr bool has_denorm_loss = false;
                
                      static constexpr char16_t 
                      infinity() noexcept { return char16_t(); }
                
                      static constexpr char16_t 
                      quiet_NaN() noexcept { return char16_t(); }
                
                      static constexpr char16_t 
                      signaling_NaN() noexcept { return char16_t(); }
                
                      static constexpr char16_t 
                      denorm_min() noexcept { return char16_t(); }
                
                      static constexpr bool is_iec559 = false;
                      static constexpr bool is_bounded = true;
                      static constexpr bool is_modulo = !is_signed;
                
                      static constexpr bool traps = __glibcxx_integral_traps;
                      static constexpr bool tinyness_before = false;
                      static constexpr float_round_style round_style = round_toward_zero;
                    };
                
                  /// numeric_limits<char32_t> specialization.
                  template<>
                    struct numeric_limits<char32_t>
                    {
                      static constexpr bool is_specialized = true;
                
                      static constexpr char32_t 
                      min() noexcept { return __glibcxx_min (char32_t); }
                
                      static constexpr char32_t 
                      max() noexcept { return __glibcxx_max (char32_t); }
                
                      static constexpr char32_t 
                      lowest() noexcept { return min(); }
                
                      static constexpr int digits = __glibcxx_digits (char32_t);
                      static constexpr int digits10 = __glibcxx_digits10 (char32_t);
                      static constexpr int max_digits10 = 0;
                      static constexpr bool is_signed = __glibcxx_signed (char32_t);
                      static constexpr bool is_integer = true;
                      static constexpr bool is_exact = true;
                      static constexpr int radix = 2;
                
                      static constexpr char32_t 
                      epsilon() noexcept { return 0; }
                
                      static constexpr char32_t 
                      round_error() noexcept { return 0; }
                
                      static constexpr int min_exponent = 0;
                      static constexpr int min_exponent10 = 0;
                      static constexpr int max_exponent = 0;
                      static constexpr int max_exponent10 = 0;
                
                      static constexpr bool has_infinity = false;
                      static constexpr bool has_quiet_NaN = false;
                      static constexpr bool has_signaling_NaN = false;
                      static constexpr float_denorm_style has_denorm = denorm_absent;
                      static constexpr bool has_denorm_loss = false;
                
                      static constexpr char32_t 
                      infinity() noexcept { return char32_t(); }
                
                      static constexpr char32_t 
                      quiet_NaN() noexcept { return char32_t(); }
                
                      static constexpr char32_t 
                      signaling_NaN() noexcept { return char32_t(); }
                
                      static constexpr char32_t 
                      denorm_min() noexcept { return char32_t(); }
                
                      static constexpr bool is_iec559 = false;
                      static constexpr bool is_bounded = true;
                      static constexpr bool is_modulo = !is_signed;
                
                      static constexpr bool traps = __glibcxx_integral_traps;
                      static constexpr bool tinyness_before = false;
                      static constexpr float_round_style round_style = round_toward_zero;
                    };
                #endif
                
                  /// numeric_limits<short> specialization.
                  template<>
                    struct numeric_limits<short>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR short 
                      min() _GLIBCXX_USE_NOEXCEPT { return -__SHRT_MAX__ - 1; }
                
                      static _GLIBCXX_CONSTEXPR short 
                      max() _GLIBCXX_USE_NOEXCEPT { return __SHRT_MAX__; }
                
                #if __cplusplus >= 201103L
                      static constexpr short 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (short);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (short);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR short 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR short 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR short 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return short(); }
                
                      static _GLIBCXX_CONSTEXPR short 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return short(); }
                
                      static _GLIBCXX_CONSTEXPR short 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return short(); }
                
                      static _GLIBCXX_CONSTEXPR short 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return short(); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<unsigned short> specialization.
                  template<>
                    struct numeric_limits<unsigned short>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR unsigned short 
                      min() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned short 
                      max() _GLIBCXX_USE_NOEXCEPT { return __SHRT_MAX__ * 2U + 1; }
                
                #if __cplusplus >= 201103L
                      static constexpr unsigned short 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits 
                       = __glibcxx_digits (unsigned short);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 
                       = __glibcxx_digits10 (unsigned short);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR unsigned short 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned short 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR unsigned short 
                      infinity() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned short>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned short 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned short>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned short 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned short>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned short 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned short>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<int> specialization.
                  template<>
                    struct numeric_limits<int>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR int 
                      min() _GLIBCXX_USE_NOEXCEPT { return -__INT_MAX__ - 1; }
                
                      static _GLIBCXX_CONSTEXPR int 
                      max() _GLIBCXX_USE_NOEXCEPT { return __INT_MAX__; }
                
                #if __cplusplus >= 201103L
                      static constexpr int 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (int);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (int);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR int 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR int 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR int 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<int>(0); }
                
                      static _GLIBCXX_CONSTEXPR int 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<int>(0); }
                
                      static _GLIBCXX_CONSTEXPR int 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<int>(0); }
                
                      static _GLIBCXX_CONSTEXPR int 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<int>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<unsigned int> specialization.
                  template<>
                    struct numeric_limits<unsigned int>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR unsigned int 
                      min() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned int 
                      max() _GLIBCXX_USE_NOEXCEPT { return __INT_MAX__ * 2U + 1; }
                
                #if __cplusplus >= 201103L
                      static constexpr unsigned int 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits 
                       = __glibcxx_digits (unsigned int);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 
                       = __glibcxx_digits10 (unsigned int);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR unsigned int 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned int 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR unsigned int 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<unsigned int>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned int 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned int>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned int 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned int>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned int 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned int>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<long> specialization.
                  template<>
                    struct numeric_limits<long>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR long
           2 ->       min() _GLIBCXX_USE_NOEXCEPT { return -__LONG_MAX__ - 1; }
                
                      static _GLIBCXX_CONSTEXPR long 
           2 ->       max() _GLIBCXX_USE_NOEXCEPT { return __LONG_MAX__; }
                
                #if __cplusplus >= 201103L
                      static constexpr long 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __glibcxx_digits (long);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 = __glibcxx_digits10 (long);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR long 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR long 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR long 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<long>(0); }
                
                      static _GLIBCXX_CONSTEXPR long 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<long>(0); }
                
                      static _GLIBCXX_CONSTEXPR long 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<long>(0); }
                
                      static _GLIBCXX_CONSTEXPR long 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<long>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<unsigned long> specialization.
                  template<>
                    struct numeric_limits<unsigned long>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR unsigned long 
                      min() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned long 
                      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_MAX__ * 2UL + 1; }
                
                #if __cplusplus >= 201103L
                      static constexpr unsigned long 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits 
                       = __glibcxx_digits (unsigned long);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 
                       = __glibcxx_digits10 (unsigned long);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR unsigned long 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned long 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR unsigned long 
                      infinity() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned long>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned long 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned long>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned long 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned long>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned long 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned long>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<long long> specialization.
                  template<>
                    struct numeric_limits<long long>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR long long 
                      min() _GLIBCXX_USE_NOEXCEPT { return -__LONG_LONG_MAX__ - 1; }
                
                      static _GLIBCXX_CONSTEXPR long long 
                      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_LONG_MAX__; }
                
                #if __cplusplus >= 201103L
                      static constexpr long long 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits 
                       = __glibcxx_digits (long long);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 
                       = __glibcxx_digits10 (long long);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR long long 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR long long 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR long long 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return static_cast<long long>(0); }
                
                      static _GLIBCXX_CONSTEXPR long long 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return static_cast<long long>(0); }
                
                      static _GLIBCXX_CONSTEXPR long long 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<long long>(0); }
                
                      static _GLIBCXX_CONSTEXPR long long 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return static_cast<long long>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<unsigned long long> specialization.
                  template<>
                    struct numeric_limits<unsigned long long>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR unsigned long long 
                      min() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned long long 
                      max() _GLIBCXX_USE_NOEXCEPT { return __LONG_LONG_MAX__ * 2ULL + 1; }
                
                #if __cplusplus >= 201103L
                      static constexpr unsigned long long 
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits 
                       = __glibcxx_digits (unsigned long long);
                      static _GLIBCXX_USE_CONSTEXPR int digits10 
                       = __glibcxx_digits10 (unsigned long long);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR unsigned long long 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned long long 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm 
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR unsigned long long 
                      infinity() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned long long>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned long long 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned long long>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned long long 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned long long>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned long long 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned long long>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_toward_zero;
                    };
                
                #if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
                  /// numeric_limits<__int128> specialization.
                  template<>
                    struct numeric_limits<__int128>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR __int128
                      min() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_min (__int128); }
                
                      static _GLIBCXX_CONSTEXPR __int128
                      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (__int128); }
                
                #if __cplusplus >= 201103L
                      static constexpr __int128
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits
                       = __glibcxx_digits (__int128);
                      static _GLIBCXX_USE_CONSTEXPR int digits10
                       = __glibcxx_digits10 (__int128);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR __int128
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR __int128
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR __int128
                      infinity() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<__int128>(0); }
                
                      static _GLIBCXX_CONSTEXPR __int128
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<__int128>(0); }
                      
                      static _GLIBCXX_CONSTEXPR __int128
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<__int128>(0); }
                      
                      static _GLIBCXX_CONSTEXPR __int128
                      denorm_min() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<__int128>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps
                       = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style
                       = round_toward_zero;
                    };
                
                  /// numeric_limits<unsigned __int128> specialization.
                  template<>
                    struct numeric_limits<unsigned __int128>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR unsigned __int128
                      min() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned __int128
                      max() _GLIBCXX_USE_NOEXCEPT { return __glibcxx_max (unsigned __int128); }
                
                #if __cplusplus >= 201103L
                      static constexpr unsigned __int128
                      lowest() noexcept { return min(); }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits
                       = __glibcxx_digits (unsigned __int128);
                      static _GLIBCXX_USE_CONSTEXPR int digits10
                       = __glibcxx_digits10 (unsigned __int128);
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10 = 0;
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = true;
                      static _GLIBCXX_USE_CONSTEXPR int radix = 2;
                
                      static _GLIBCXX_CONSTEXPR unsigned __int128
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_CONSTEXPR unsigned __int128
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = 0;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = 0;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = false;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
                       = denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss = false;
                
                      static _GLIBCXX_CONSTEXPR unsigned __int128
                      infinity() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned __int128>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned __int128
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned __int128>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned __int128
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned __int128>(0); }
                
                      static _GLIBCXX_CONSTEXPR unsigned __int128
                      denorm_min() _GLIBCXX_USE_NOEXCEPT
                      { return static_cast<unsigned __int128>(0); }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559 = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = true;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_integral_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = false;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style
                       = round_toward_zero;
                    };
                #endif
                
                  /// numeric_limits<float> specialization.
                  template<>
                    struct numeric_limits<float>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR float 
                      min() _GLIBCXX_USE_NOEXCEPT { return __FLT_MIN__; }
                
                      static _GLIBCXX_CONSTEXPR float 
                      max() _GLIBCXX_USE_NOEXCEPT { return __FLT_MAX__; }
                
                #if __cplusplus >= 201103L
                      static constexpr float 
                      lowest() noexcept { return -__FLT_MAX__; }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __FLT_MANT_DIG__;
                      static _GLIBCXX_USE_CONSTEXPR int digits10 = __FLT_DIG__;
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10
                	 = __glibcxx_max_digits10 (__FLT_MANT_DIG__);
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;
                      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;
                
                      static _GLIBCXX_CONSTEXPR float 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return __FLT_EPSILON__; }
                
                      static _GLIBCXX_CONSTEXPR float 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5F; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __FLT_MIN_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __FLT_MIN_10_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __FLT_MAX_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __FLT_MAX_10_EXP__;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __FLT_HAS_INFINITY__;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
                	= bool(__FLT_HAS_DENORM__) ? denorm_present : denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss 
                       = __glibcxx_float_has_denorm_loss;
                
                      static _GLIBCXX_CONSTEXPR float 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_valf(); }
                
                      static _GLIBCXX_CONSTEXPR float 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nanf(""); }
                
                      static _GLIBCXX_CONSTEXPR float 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nansf(""); }
                
                      static _GLIBCXX_CONSTEXPR float 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __FLT_DENORM_MIN__; }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559
                	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_float_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before 
                       = __glibcxx_float_tinyness_before;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_to_nearest;
                    };
                
                #undef __glibcxx_float_has_denorm_loss
                #undef __glibcxx_float_traps
                #undef __glibcxx_float_tinyness_before
                
                  /// numeric_limits<double> specialization.
                  template<>
                    struct numeric_limits<double>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR double 
                      min() _GLIBCXX_USE_NOEXCEPT { return __DBL_MIN__; }
                
                      static _GLIBCXX_CONSTEXPR double 
                      max() _GLIBCXX_USE_NOEXCEPT { return __DBL_MAX__; }
                
                #if __cplusplus >= 201103L
                      static constexpr double 
                      lowest() noexcept { return -__DBL_MAX__; }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __DBL_MANT_DIG__;
                      static _GLIBCXX_USE_CONSTEXPR int digits10 = __DBL_DIG__;
                #if __cplusplus >= 201103L
                      static constexpr int max_digits10
                	 = __glibcxx_max_digits10 (__DBL_MANT_DIG__);
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;
                      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;
                
                      static _GLIBCXX_CONSTEXPR double 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return __DBL_EPSILON__; }
                
                      static _GLIBCXX_CONSTEXPR double 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __DBL_MIN_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __DBL_MIN_10_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __DBL_MAX_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __DBL_MAX_10_EXP__;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __DBL_HAS_INFINITY__;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
                	= bool(__DBL_HAS_DENORM__) ? denorm_present : denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss 
                        = __glibcxx_double_has_denorm_loss;
                
                      static _GLIBCXX_CONSTEXPR double 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_val(); }
                
                      static _GLIBCXX_CONSTEXPR double 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nan(""); }
                
                      static _GLIBCXX_CONSTEXPR double 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nans(""); }
                
                      static _GLIBCXX_CONSTEXPR double 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __DBL_DENORM_MIN__; }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559
                	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_double_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before 
                       = __glibcxx_double_tinyness_before;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style 
                       = round_to_nearest;
                    };
                
                #undef __glibcxx_double_has_denorm_loss
                #undef __glibcxx_double_traps
                #undef __glibcxx_double_tinyness_before
                
                  /// numeric_limits<long double> specialization.
                  template<>
                    struct numeric_limits<long double>
                    {
                      static _GLIBCXX_USE_CONSTEXPR bool is_specialized = true;
                
                      static _GLIBCXX_CONSTEXPR long double 
                      min() _GLIBCXX_USE_NOEXCEPT { return __LDBL_MIN__; }
                
                      static _GLIBCXX_CONSTEXPR long double 
                      max() _GLIBCXX_USE_NOEXCEPT { return __LDBL_MAX__; }
                
                #if __cplusplus >= 201103L
                      static constexpr long double 
                      lowest() noexcept { return -__LDBL_MAX__; }
                #endif
                
                      static _GLIBCXX_USE_CONSTEXPR int digits = __LDBL_MANT_DIG__;
                      static _GLIBCXX_USE_CONSTEXPR int digits10 = __LDBL_DIG__;
                #if __cplusplus >= 201103L
                      static _GLIBCXX_USE_CONSTEXPR int max_digits10
                	 = __glibcxx_max_digits10 (__LDBL_MANT_DIG__);
                #endif
                      static _GLIBCXX_USE_CONSTEXPR bool is_signed = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_integer = false;
                      static _GLIBCXX_USE_CONSTEXPR bool is_exact = false;
                      static _GLIBCXX_USE_CONSTEXPR int radix = __FLT_RADIX__;
                
                      static _GLIBCXX_CONSTEXPR long double 
                      epsilon() _GLIBCXX_USE_NOEXCEPT { return __LDBL_EPSILON__; }
                
                      static _GLIBCXX_CONSTEXPR long double 
                      round_error() _GLIBCXX_USE_NOEXCEPT { return 0.5L; }
                
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent = __LDBL_MIN_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int min_exponent10 = __LDBL_MIN_10_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent = __LDBL_MAX_EXP__;
                      static _GLIBCXX_USE_CONSTEXPR int max_exponent10 = __LDBL_MAX_10_EXP__;
                
                      static _GLIBCXX_USE_CONSTEXPR bool has_infinity = __LDBL_HAS_INFINITY__;
                      static _GLIBCXX_USE_CONSTEXPR bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;
                      static _GLIBCXX_USE_CONSTEXPR bool has_signaling_NaN = has_quiet_NaN;
                      static _GLIBCXX_USE_CONSTEXPR float_denorm_style has_denorm
                	= bool(__LDBL_HAS_DENORM__) ? denorm_present : denorm_absent;
                      static _GLIBCXX_USE_CONSTEXPR bool has_denorm_loss
                	= __glibcxx_long_double_has_denorm_loss;
                
                      static _GLIBCXX_CONSTEXPR long double 
                      infinity() _GLIBCXX_USE_NOEXCEPT { return __builtin_huge_vall(); }
                
                      static _GLIBCXX_CONSTEXPR long double 
                      quiet_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nanl(""); }
                
                      static _GLIBCXX_CONSTEXPR long double 
                      signaling_NaN() _GLIBCXX_USE_NOEXCEPT { return __builtin_nansl(""); }
                
                      static _GLIBCXX_CONSTEXPR long double 
                      denorm_min() _GLIBCXX_USE_NOEXCEPT { return __LDBL_DENORM_MIN__; }
                
                      static _GLIBCXX_USE_CONSTEXPR bool is_iec559
                	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
                      static _GLIBCXX_USE_CONSTEXPR bool is_bounded = true;
                      static _GLIBCXX_USE_CONSTEXPR bool is_modulo = false;
                
                      static _GLIBCXX_USE_CONSTEXPR bool traps = __glibcxx_long_double_traps;
                      static _GLIBCXX_USE_CONSTEXPR bool tinyness_before = 
                					 __glibcxx_long_double_tinyness_before;
                      static _GLIBCXX_USE_CONSTEXPR float_round_style round_style = 
                						      round_to_nearest;
                    };
                
                #undef __glibcxx_long_double_has_denorm_loss
                #undef __glibcxx_long_double_traps
                #undef __glibcxx_long_double_tinyness_before
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #undef __glibcxx_signed
                #undef __glibcxx_min
                #undef __glibcxx_max
                #undef __glibcxx_digits
                #undef __glibcxx_digits10
                #undef __glibcxx_max_digits10
                
                #endif // _GLIBCXX_NUMERIC_LIMITS


Top 10 Lines:

     Line      Count

     1126          2
     1129          2

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        4   Total number of line executions
     2.00   Average executions per line


*** File /home/niina/greens_functions/GreensFunction3D.hpp:
                #if !defined( __FREEPAIRGREENSFUNCTION )
                #define __FREEPAIRGREENSFUNCTION 
                
                #include "compat.h"
                
                #include <gsl/gsl_integration.h>
                
                //#include "Logger.hpp"
                #include "PairGreensFunction.hpp"
                
                /**
                   Pair Green's function for the case where the pair never interact.
                
                   Therefore, drawTime() always returns +INFINITY.
                   kf == sigma == 0.
                */
                
                namespace greens_functions{
                
                class GreensFunction3D: public PairGreensFunction
                {
                    
                private:
                
                    static const Real TOLERANCE = 1e-8;
                
                    static const Real H = 7;
                    
                public:
                    
           1 ->     GreensFunction3D(Real D, Real r0)
                        : PairGreensFunction(D, 0.0, r0, 0.0)
                    {
                        ; // do nothing
                    }
                    
                    
                    virtual ~GreensFunction3D();
                    
                    virtual Real drawTime(Real rnd) const;
                
                    Real drawR(Real rnd, Real t) const;
                    
                    Real drawTheta(Real rnd, Real r, Real t) const;
                
                    Real p_r(Real r, Real t) const;
                
                    Real ip_r(Real r, Real t ) const;
                    
                
                    Real p_theta(Real theta, Real r, Real t) const;
                
                    Real ip_theta(Real theta, Real r, Real t ) const;
                
                    std::string dump() const;
                
                    const char* getName() const
                    {
                        return "GreensFunction3D";
                    }
                
                /*private:
                    static Logger& log_;*/
                };
                
                }
                #endif // __PLAINPAIRGREENSFUNCTION 


Top 10 Lines:

     Line      Count

       31          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/niina/greens_functions/GreensFunction1DAbsAbs.hpp:
                #if !defined( __GREENSFUNCTION1DABSABS_HPP )
                #define __GREENSFUNCTION1DABSABS_HPP
                
                #include <sstream>
                #include <iostream>
                #include <cstdlib>
                #include <exception>
                #include <vector>
                
                #include <gsl/gsl_math.h>
                #include <gsl/gsl_sf_trig.h>
                #include <gsl/gsl_sum.h>
                #include <gsl/gsl_errno.h>
                #include <gsl/gsl_interp.h>
                #include <gsl/gsl_sf_expint.h>
                #include <gsl/gsl_sf_elljac.h>
                #include <gsl/gsl_roots.h>
                
                #include <math.h>
                
                #include "findRoot.hpp"
                #include "Defs.hpp"
                #include "funcSum.hpp"
                #include "freeFunctions.hpp"
                //#include "Logger.hpp"
                
                #include "GreensFunction.hpp"
                #include "PairGreensFunction.hpp"	// needed to declare EventType
                
                namespace greens_functions{
                
                class GreensFunction1DAbsAbs: public GreensFunction
                {
                public:
                    typedef std::vector<Real> RealVector;
                    typedef unsigned int uint;
                
                private:
                    // This is a typical length scale of the system, may not be true!
                    static const Real L_TYPICAL = 1E-8;
                    // The typical timescale of the system, may also not be true!!
                    static const Real T_TYPICAL = 1E-6;
                    // measure of 'sameness' when comparing floating points numbers
                    static const Real EPSILON = 1E-10;
                    //E3; Is 1E3 a good measure for the probability density?!
                    static const Real PDENS_TYPICAL = 1;
                    // The maximum number of terms in the sum
                    static const uint MAX_TERMS = 500;
                    // The minimum
                    static const uint MIN_TERMS = 20;
                    // Cutoff distance: When H * sqrt(2Dt) < 1/2*L, use free greensfunction instead of absorbing.
                    static const Real CUTOFF_H = 6.0;
                
                
                public:
           1 ->     GreensFunction1DAbsAbs(Real D, Real r0, Real sigma, Real a)
                	: GreensFunction(D), v(0.0), sigma(sigma), a(a), r0(r0), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
                    {
                	;   // do nothing
                    }
                
                    // The constructor is overloaded and can be called with or without drift v
                    GreensFunction1DAbsAbs(Real D, Real v, Real r0, Real sigma, Real a) // copy constructor including drift variable v
                	: GreensFunction(D), v(v), sigma(sigma), a(a), r0(r0), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
                    {
                	;   // do nothing
                    }
                
           1 ->     ~GreensFunction1DAbsAbs()
                    { 
                	;   // empty
                    }
                
                    // This also sets the scale
                    void seta(Real a)
                    {
                	Real L( a - this->sigma );
                	
                	THROW_UNLESS( std::invalid_argument, L >= 0.0 && (this->r0 - sigma) <= L);
                
                	// Use a typical domain size to determine if we are here
                	// defining a domain of size 0.
                	if ( L <= EPSILON * l_scale )
                	{
                	    // just some random value to show that the domain is zero
                	    this->a = -INT_MAX;
                	}
                	else
                	{   
                	    // set the typical time scale (msd = sqrt(2*d*D*t) )
                	    // this is needed by drawTime_f, do not get rid of it!
                	    this->t_scale = (L*L)/this->getD();
                	    // set a
                	    this->a = a;
                	}
                    }
                
                    Real getsigma() const
                    {
                	return this->sigma;
                    }
                 
                    Real geta() const
                    {
                	return this->a;
                    }
                
                    Real getv() const
                    {
                	return this->v;
                    }
                
                    void setr0(Real r0)
                    {
                	if ( this->a - this->sigma < 0.0 )
                	{
                	    // if the domain had zero size    
                	    THROW_UNLESS( std::invalid_argument,
                	                  0.0 <= (r0-sigma) && (r0-sigma) <= EPSILON * l_scale );
                	    this->r0 = 0.0;
                	}
                	else
                	{
                	    // The normal case
                	    THROW_UNLESS( std::invalid_argument,
                	                  0.0 <= (r0-sigma) && r0 <= this->a);
                	    this->r0 = r0;
                	}
                    }
                
                    Real getr0() const
                    {
                	return this->r0;
                    }
                
                    // Draws the first passage time from the propensity function
                    Real drawTime (Real rnd) const;
                
                    // Draws the position of the particle at a given time, assuming that 
                    // the particle is still in the
                    // domain
                    Real drawR (Real rnd, Real t) const;
                
                    // Calculates the amount of flux leaving the left boundary at time t
                    Real leaves(Real t) const;
                
                    // Calculates the amount of flux leaving the right boundary at time t
                    Real leavea(Real t) const;
                
                    // Determines based on the flux ratios if the particle left the left 
                    // or right boundary
                    EventKind drawEventType( Real rnd, Real t ) const;
                
                    // Calculates the probability of finding the particle inside the 
                    // domain at time t so, the survival probability
                    Real p_survival (Real t) const;
                
                    // Calculates the probability density of finding the particle at 
                    // location z at timepoint t, given that the particle is still in the 
                    // domain.
                    Real calcpcum (Real r, Real t) const;
                    
                    // Calculates the probability density of finding the particle at 
                    // location r at time t.
                    Real prob_r (Real r, Real t) const;
                
                    std::string dump() const;
                
                    const char* getName() const
                    {
                        return "GreensFunction1DAbsAbs";
                    }
                
                private:
                    struct drawT_params
                    {
                        GreensFunction1DAbsAbs const* gf;
                        RealVector& psurvTable;
                        Real rnd;
                    };
                
                   struct drawR_params
                    {
                        GreensFunction1DAbsAbs const* gf;
                        const Real t;
                        RealVector table;
                        Real rnd;
                    };
                
                    uint guess_maxi(Real const& t ) const;
                
                
                    static Real drawT_f (Real t, void *p);
                
                    Real p_survival_table( Real  t, RealVector& psurvTable ) const;
                
                    Real p_survival_i(uint i, Real const& t, RealVector const& table ) const;
                
                    Real p_survival_table_i_v( uint const& i ) const;
                
                    Real p_survival_table_i_nov( uint const& i ) const;
                
                    void createPsurvTable( uint const& maxi, RealVector& table) const;
                
                
                    static Real drawR_f (Real z, void* p);
                
                    Real p_int_r_table(Real const& r, Real const& t, RealVector& table) const;
                
                    Real p_int_r_i(uint i, Real const& r, Real const& t, RealVector& table) const;
                
                    void create_p_int_r_Table( Real const& t, uint const& maxi, RealVector& table ) const;
                
                    Real get_p_int_r_Table_i( uint& i, Real const& t, RealVector& table ) const
                    {
                        if( i >= table.size() )
                        {
                            create_p_int_r_Table(t, i+1, table);
                        }
                
                        return table[i];
                    }
                
                private:
                    // The diffusion constant and drift velocity
                    Real v;
                    // These are the dimensions of our domain; L is calculated as a-sigma
                    Real sigma;
                    Real a;
                    Real r0;
                    // This is the 'length scale' of your system (1e-14 or 1e6)
                    // Although rescaling is discontinued, we use it to check whether a is well-chosen
                    Real l_scale;
                    // This is the time scale of the system, used by drawTime_f
                    Real t_scale;
                
                //    static Logger& log_;
                };
                
                }
                #endif // __GREENSFUNCTION1DABSABS_HPP


Top 10 Lines:

     Line      Count

       56          1
       69          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /home/niina/greens_functions/GreensFunction1DAbsSinkAbs.hpp:
                #if !defined( __GREENSFUNCTION1DABSSINKABS_HPP )
                #define __GREENSFUNCTION1DABSSINKABS_HPP
                
                #include <sstream>
                #include <iostream>
                #include <cstdlib>
                #include <exception>
                #include <vector>
                
                #include <gsl/gsl_math.h>
                #include <gsl/gsl_sf_trig.h>
                #include <gsl/gsl_sum.h>
                #include <gsl/gsl_errno.h>
                #include <gsl/gsl_interp.h>
                #include <gsl/gsl_sf_expint.h>
                #include <gsl/gsl_sf_elljac.h>
                #include <gsl/gsl_roots.h>
                
                #include <math.h>
                
                #include "findRoot.hpp"
                #include "Defs.hpp"
                #include "GreensFunction.hpp"
                #include "funcSum.hpp"
                #include "freeFunctions.hpp"
                //#include "Logger.hpp"
                
                namespace greens_functions{
                
                class GreensFunction1DAbsSinkAbs: public GreensFunction
                {
                public:
                    typedef std::pair<Real, Real> real_pair;
                    typedef std::vector<Real> RealVector;
                    typedef unsigned int uint;
                
                private:
                    // This is a typical length scale of the system, may not be true!
                    static const Real L_TYPICAL = 1E-8;
                    // The typical timescale of the system, may also not be true!!
                    static const Real T_TYPICAL = 1E-6;
                    // measure of 'sameness' when comparing floating points numbers
                    static const Real EPSILON = 1E-10;
                    // Is 1E3 a good measure for the probability density?!
                    static const Real PDENS_TYPICAL = 1;
                    // The maximum number of terms used in calculating the sum
                    static const uint MAX_TERMS = 500;
                    // The minimum number of terms
                    static const uint MIN_TERMS = 20;
                    /* Cutoff distance: When H * sqrt(2Dt) < a - r0 OR ro - sigma
                       use free greensfunction instead of absorbing. */
                    static const Real CUTOFF_H = 6.0;
                
                
                public:
           1 ->     GreensFunction1DAbsSinkAbs(Real D, Real k, Real r0, Real rsink, Real sigma, Real a)
                	: GreensFunction(D), k(k), r0(r0), sigma(sigma), a(a), rsink(rsink), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
                    {
                	    /* Set variables which define a domain with the sink at the origin. 
                	       Futhermore r0 is assumed to be ringht from the sink. */
                	    assert( a > sigma );
                	    
                	    L0 = fabs( r0 - rsink ); 
                	    if( r0 >= rsink )
                	    {
                	        Lr = a - rsink; 
                	        Ll = rsink - sigma;	        
                	    }
                	    else
                	    {
                	        Lr = rsink - sigma; 
                	        Ll = a - rsink;
                	    }
                
                        calculate_n_roots( 1 );
                    }
                
           1 ->     ~GreensFunction1DAbsSinkAbs()
                    {
                	;   // empty
                    }
                
                    Real geta() const
                    {
                	    return a;
                    }
                    
                    Real getLr() const
                    {
                	    return Lr;
                    }
                    
                    Real getLl() const
                    {
                	    return Ll;
                    }
                    
                    Real getL0() const
                    {
                	    return L0;
                    }
                
                    Real getrsink() const
                    {
                	    return rsink;
                    }
                    
                    Real getsigma() const
                    {
                	    return sigma;
                    }
                
                    Real getr0() const
                    {
                	    return r0;
                    }
                
                    Real getk() const
                    {
                	    return k;
                    }
                
                    /* Calculates the probability density of finding the particle at 
                       location z at timepoint t, given that the particle is still in the 
                       domain. */
                    Real calcpcum(Real r, Real t) const;
                
                    /* Determine which event has occured at time t. Either an escape 
                       (left or right boundary) or a reaction with the sink. 
                       Based on the fluxes through the boundaries at the given time. */
                    EventKind drawEventType( Real rnd, Real t ) const;
                
                    /* Draws the first passage time from the propensity function */
                    Real drawTime(Real rnd) const;
                
                    /* Draws the position of the particle at a given time, assuming that 
                       the particle is still in the domain. */
                    Real drawR(Real rnd, Real t) const;
                
                    /* Calculates the probability flux leaving the domain through the right 
                       absorbing boundary at time t. */
                    Real flux_leavea(Real t) const;
                
                    /* Calculates the probability flux leaving the domain through the left 
                       absorbing boundary at time t. */
                    Real flux_leaves(Real t) const;
                
                    /* Calculates the probability flux leaving the domain through the sink 
                       at time t. */
                    Real flux_sink(Real t) const;
                
                    /* Calculates the probability of finding the particle inside the 
                       domain at time t -> the survival probability */
                    Real p_survival(Real t) const;
                
                    /* c.d.f. of the greensfunction with respect to position. */
                    Real p_int_r_table( Real const& r, Real const& t, RealVector& table ) const;
                
                    Real p_int_r(Real const& r, Real const& t) const;
                
                    /* TODO: Private methods which are public for now - debugging */
                
                    /* Calculates the total probability flux leaving the domain at time t. */
                    Real flux_tot(Real t) const;
                
                    /* Calculates the probability flux leaving the domain through the 
                       sub-domain containing r0 via the absorbing boundary and the flux 
                       leaving the sub-domain not containing r0 via the absorbing boundary. */
                    Real flux_abs_Lr(Real t, uint const& maxi) const;
                    Real flux_abs_Ll(Real t, uint const& maxi) const;
                
                    /* Calculates the probability density of finding the particle at 
                       location r at time t. */
                    Real prob_r(Real r, Real t) const;
                    
                    std::string dump() const;
                
                    const char* getName() const
                    {
                        return "GreensFunction1DAbsSinkAbs";
                    }
                
                private:
                    /* used structures */
                
                    struct drawR_params
                    {
                        GreensFunction1DAbsSinkAbs const* gf;
                        const Real t;
                   	    RealVector& table;
                	    const Real rnd;
                    };
                
                    struct drawT_params
                    {
                	    GreensFunction1DAbsSinkAbs const* gf;
                	    RealVector& table;
                	    const Real rnd;
                    };
                
                    struct root_f_params
                    {
                	    Real Lm_L;
                	    Real h;
                    };
                
                    struct lower_upper_params
                    {
                        Real h;
                        Real Lm_L;
                        Real long_period;
                        Real short_period;
                        Real last_long_root;
                        Real last_short_root;
                        bool last_was_long;
                    };
                
                
                    /* Functions managing the rootList */
                    
                    /* return the rootList size */
                    uint rootList_size() const
                    {
                        return rootList.size();
                    }
                
                    /* returns the last root. */
                    Real get_last_root() const
                    {
                        return rootList.back();
                    }
                
                    /* ad a root to the rootList */
                    void ad_to_rootList( Real const& root_i ) const
                    {
                        rootList.push_back( root_i );
                    }
                
                    /* remove n'th root from rootList */
                    void remove_from_rootList(uint const& n) const
                    {
                        rootList.erase( rootList.begin() + n );
                    }
                
                    /* return the n + 1'th root */
                    Real get_root( uint const& n ) const
                    {
                        if( n >= rootList.size() )
                            calculate_n_roots( n+1 );
                
                        return rootList[ n ];
                    }
                
                
                    /* Functions concerned with finding the roots. */
                
                    /* Fills the rootList with the first n roots */
                    void calculate_n_roots( uint const& n ) const;
                    
                    /* Function returns two positions on the x-axis which straddle the next root. */
                    real_pair get_lower_and_upper() const;
                
                    /* Function of which we need the roots. */
                    static Real root_f(Real x, void *p);
                
                    /* Guess the number of terms needed for convergence, given t. */
                    uint guess_maxi( Real const& t ) const;
                
                
                    /* Function for calculating the survival probability. */
                    Real p_survival_table(Real t, RealVector& psurvTable) const;
                
                    Real p_survival_i( uint i, Real const& t, RealVector const& table ) const;
                
                    Real p_survival_table_i( Real const& root_i ) const;
                    
                    void createPsurvTable( RealVector& table ) const;
                
                
                    /* Functions for calculating the greensfunction. */
                    Real prob_r_r0_i(uint i, Real const& rr, Real const& t) const;
                
                    Real prob_r_nor0_i( uint i, Real const& rr, Real const& t) const;
                
                
                    /* Functions for calculating the fluxes. */
                    Real flux_tot_i(uint i, Real const& t) const;
                
                    Real flux_abs_Lr_i(uint i, Real const& t) const;
                
                    Real flux_abs_Ll_i(uint i, Real const& t) const;
                
                
                
                    /* functions for calculating the c.d.f. */
                
                    /* i'th term of p_int_r(r') for r' in left domain */
                    Real p_int_r_leftdomain(uint i, Real const& rr, Real const& t, RealVector& table) const;
                
                    /* i'th term of p_int_r(r') for r' in right domain, left of r0 */
                    Real p_int_r_rightdomainA(uint i, Real const& rr, Real const& t, RealVector& table) const;
                
                    /* i'th term of p_int_r(r') for r' in right domain, right of r0 */
                    Real p_int_r_rightdomainB(uint i, Real const& rr, Real const& t, RealVector& table) const;
                
                    /* Fills table with r-independent part of p_int_r_i. */
                    void create_p_int_r_Table( Real const& t, RealVector& table ) const;
                
                    /* Returns i'th r-independent term of p_int_r_i.
                       Term is created if not in table. */
                    Real get_p_int_r_Table_i( uint& i, Real const& t, RealVector& table) const
                    {
                        if( i >= table.size() )
                        {
                            calculate_n_roots( i+1 );
                            create_p_int_r_Table( t, table );
                        }
                
                        return table[i];
                    }
                
                    /* Denominator of the Greens function */
                    inline Real p_denominator_i( Real const& root_n ) const;
                    
                    /* Standard form of Greens Function: exp( -Dt root_n ** 2 ) / denominator */
                    inline Real p_exp_den_i(Real const& t, Real const& root_n, Real const& root_n2) const;
                
                    /* Function for drawR */
                    static Real drawT_f (Real t, void *p);
                
                    /* Function for drawTime */
                    static Real drawR_f (Real r, void *p);
                
                    
                    /* Class variables */
                
                    // The reaction constant
                    const Real k;
                    //starting position
                    const Real r0;
                    // The left and right boundary of the domain (sets the l_scale, see below)
                    const Real sigma;
                    const Real a;
                    //Position of the sink in the domain.
                    const Real rsink;
                    // This is the length scale of the system
                    Real l_scale;
                    // This is the time scale of the system.
                    Real t_scale;
                    
                    /* Greensfunction assumes that the sink is at the origin, and
                       consists of two sub-domains: one between a boundary and the sink including
                       r0, and one between boundary and sink not inlcuding r0. */
                
                    // Length of sub-domain which does not include r0.
                    Real Lr;
                    // Length of sub-domain which does include r0.
                    Real Ll;
                    // Distance between the sink and r0.
                    Real L0;
                
                    // Stores all the roots.
                    mutable RealVector rootList;
                
                    // Stores params for rootfiner.
                    mutable struct lower_upper_params lo_up_params;
                
                //    static Logger& log_;
                };
                
                }
                #endif // __GREENSFUNCTION1DRADABS_HPP


Top 10 Lines:

     Line      Count

       56          1
       78          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_pair.h:
                // Pair implementation -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_pair.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _STL_PAIR_H
                #define _STL_PAIR_H 1
                
                #include <bits/move.h> // for std::move / std::forward, and std::swap
                
                #if __cplusplus >= 201103L
                #include <type_traits> // for std::__decay_and_strip too
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                #if __cplusplus >= 201103L
                  /// piecewise_construct_t
                  struct piecewise_construct_t { };
                
                  /// piecewise_construct
                  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
                
                  // Forward declarations.
                  template<typename...>
                    class tuple;
                
                  template<std::size_t...>
                    struct _Index_tuple;
                #endif
                
                 /**
                   *  @brief Struct holding two objects of arbitrary type.
                   *
                   *  @tparam _T1  Type of first object.
                   *  @tparam _T2  Type of second object.
                   */
                  template<class _T1, class _T2>
                    struct pair
                    {
                      typedef _T1 first_type;    /// @c first_type is the first bound type
                      typedef _T2 second_type;   /// @c second_type is the second bound type
                
                      _T1 first;                 /// @c first is a copy of the first object
                      _T2 second;                /// @c second is a copy of the second object
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 265.  std::pair::pair() effects overly restrictive
                      /** The default constructor creates @c first and @c second using their
                       *  respective default constructors.  */
                      _GLIBCXX_CONSTEXPR pair()
                      : first(), second() { }
                
                      /** Two objects may be passed to a @c pair constructor to be copied.  */
           2 ->       _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                
                      /** There is also a templated copy ctor for the @c pair class itself.  */
                #if __cplusplus < 201103L
                      template<class _U1, class _U2>
                	pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                #else
                      template<class _U1, class _U2, class = typename
                	       enable_if<__and_<is_convertible<const _U1&, _T1>,
                				is_convertible<const _U2&, _T2>>::value>::type>
                	constexpr pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                
                      constexpr pair(const pair&) = default;
                      constexpr pair(pair&&) = default;
                
                      // DR 811.
                      template<class _U1, class = typename
                	       enable_if<is_convertible<_U1, _T1>::value>::type>
                	constexpr pair(_U1&& __x, const _T2& __y)
                	: first(std::forward<_U1>(__x)), second(__y) { }
                
                      template<class _U2, class = typename
                	       enable_if<is_convertible<_U2, _T2>::value>::type>
                	constexpr pair(const _T1& __x, _U2&& __y)
                	: first(__x), second(std::forward<_U2>(__y)) { }
                
                      template<class _U1, class _U2, class = typename
                	       enable_if<__and_<is_convertible<_U1, _T1>,
                				is_convertible<_U2, _T2>>::value>::type>
                	constexpr pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                
                      template<class _U1, class _U2, class = typename
                	       enable_if<__and_<is_convertible<_U1, _T1>,
                				is_convertible<_U2, _T2>>::value>::type>
                	constexpr pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      template<typename... _Args1, typename... _Args2>
                        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
                
                      pair&
                      operator=(const pair& __p)
                      {
                	first = __p.first;
                	second = __p.second;
                	return *this;
                      }
                
                      pair&
                      operator=(pair&& __p)
                      noexcept(__and_<is_nothrow_move_assignable<_T1>,
                	              is_nothrow_move_assignable<_T2>>::value)
                      {
                	first = std::forward<first_type>(__p.first);
                	second = std::forward<second_type>(__p.second);
                	return *this;
                      }
                
                      template<class _U1, class _U2>
                	pair&
                	operator=(const pair<_U1, _U2>& __p)
                	{
                	  first = __p.first;
                	  second = __p.second;
                	  return *this;
                	}
                
                      template<class _U1, class _U2>
                	pair&
                	operator=(pair<_U1, _U2>&& __p)
                	{
                	  first = std::forward<_U1>(__p.first);
                	  second = std::forward<_U2>(__p.second);
                	  return *this;
                	}
                
                      void
                      swap(pair& __p)
                      noexcept(noexcept(swap(first, __p.first))
                	       && noexcept(swap(second, __p.second)))
                      {
                	using std::swap;
                	swap(first, __p.first);
                	swap(second, __p.second);
                      }
                
                    private:
                      template<typename... _Args1, std::size_t... _Indexes1,
                               typename... _Args2, std::size_t... _Indexes2>
                        pair(tuple<_Args1...>&, tuple<_Args2...>&,
                             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
                #endif
                    };
                
                  /// Two pairs of the same type are equal iff their members are equal.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first == __y.first && __x.second == __y.second; }
                
                  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first < __y.first
                	     || (!(__y.first < __x.first) && __x.second < __y.second); }
                
                  /// Uses @c operator== to find the result.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x == __y); }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __y < __x; }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__y < __x); }
                
                  /// Uses @c operator< to find the result.
                  template<class _T1, class _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x < __y); }
                
                #if __cplusplus >= 201103L
                  /// See std::pair::swap().
                  // Note:  no std::swap overloads in C++03 mode, this has performance
                  //        implications, see, eg, libstdc++/38466.
                  template<class _T1, class _T2>
                    inline void
                    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                    noexcept(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                #endif
                
                  /**
                   *  @brief A convenience wrapper for creating a pair from two objects.
                   *  @param  __x  The first object.
                   *  @param  __y  The second object.
                   *  @return   A newly-constructed pair<> object of the appropriate type.
                   *
                   *  The standard requires that the objects be passed by reference-to-const,
                   *  but LWG issue #181 says they should be passed by const value.  We follow
                   *  the LWG by default.
                   */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 181.  make_pair() unintended behavior
                #if __cplusplus >= 201103L
                  // NB: DR 706.
                  template<class _T1, class _T2>
                    constexpr pair<typename __decay_and_strip<_T1>::__type,
                                   typename __decay_and_strip<_T2>::__type>
                    make_pair(_T1&& __x, _T2&& __y)
                    {
                      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
                      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
                      typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
                      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
                    }
                #else
                  template<class _T1, class _T2>
                    inline pair<_T1, _T2>
                    make_pair(_T1 __x, _T2 __y)
                    { return pair<_T1, _T2>(__x, __y); }
                #endif
                
                  /// @}
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_PAIR_H */


Top 10 Lines:

     Line      Count

      112          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File /home/niina/greens_functions/PairGreensFunction.hpp:
                #if !defined( __PAIRGREENSFUNCTION_HPP )
                #define __PAIRGREENSFUNCTION_HPP
                
                #include "Defs.hpp"
                #include <string>
                #include "GreensFunction.hpp"
                
                namespace greens_functions{
                
                class PairGreensFunction: public GreensFunction
                {
                public:
           1 ->     PairGreensFunction(Real D, Real kf, Real r0, Real Sigma)
                      : GreensFunction(D), kf(kf), r0(r0), Sigma(Sigma) {}
                    
       ##### ->     virtual ~PairGreensFunction() {}
                    
                    Real getD() const
                    {
                        return this->D;
                    }
                    
                    Real getkf() const
                    {
                        return this->kf;
                    }
                    
                    Real getSigma() const
                    {
                        return this->Sigma;
                    }
                
                    Real getr0() const
                    {
                        return this->r0;
                    }
                
                    virtual std::string dump() const = 0;
                
                    virtual const char* getName() const = 0;
                
                    virtual Real drawTime(Real rnd) const = 0;
                    
                    virtual Real drawR(Real rnd, Real t) const = 0;
                    
                    virtual Real drawTheta(Real rnd, Real r, Real t) const = 0;
                
                protected:
                  const Real kf;
                  const Real r0;
                  const Real Sigma;
                };
                
                }
                #endif /* __PAIRGREENSFUNCTION_HPP */


Top 10 Lines:

     Line      Count

       13          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_construct.h:
                // nonstandard construct and destroy functions -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_construct.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_CONSTRUCT_H
                #define _STL_CONSTRUCT_H 1
                
                #include <new>
                #include <bits/move.h>
                #include <ext/alloc_traits.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * Constructs an object in existing memory by invoking an allocated
                   * object's constructor with an initializer.
                   */
                #if __cplusplus >= 201103L
                  template<typename _T1, typename... _Args>
                    inline void
                    _Construct(_T1* __p, _Args&&... __args)
                    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
                #else
                  template<typename _T1, typename _T2>
                    inline void
                    _Construct(_T1* __p, const _T2& __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1(__value);
                    }
                #endif
                
                  /**
                   * Destroy the object pointed to by a pointer type.
                   */
                  template<typename _Tp>
                    inline void
                    _Destroy(_Tp* __pointer)
                    { __pointer->~_Tp(); }
                
                  template<bool>
                    struct _Destroy_aux
                    {
                      template<typename _ForwardIterator>
                        static void
                        __destroy(_ForwardIterator __first, _ForwardIterator __last)
                	{
                	  for (; __first != __last; ++__first)
                	    std::_Destroy(std::__addressof(*__first));
                	}
                    };
                
                  template<>
                    struct _Destroy_aux<true>
                    {
                      template<typename _ForwardIterator>
                        static void
     1920861 ->         __destroy(_ForwardIterator, _ForwardIterator) { }
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator>
                    inline void
     1920861 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy(__first, __last);
                    }
                
                  /**
                   * Destroy a range of objects using the supplied allocator.  For
                   * nondefault allocators we do not optimize away invocation of 
                   * destroy() even if _Tp has a trivial destructor.
                   */
                
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     _Allocator& __alloc)
                    {
                      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                      for (; __first != __last; ++__first)
                	__traits::destroy(__alloc, std::__addressof(*__first));
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
     1582608 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     allocator<_Tp>&)
                    {
                      _Destroy(__first, __last);
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_CONSTRUCT_H */
                


Top 10 Lines:

     Line      Count

      112    1920861
      122    1920861
      148    1582608

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

  5424330   Total number of line executions
1808110.00   Average executions per line


*** File /usr/include/c++/4.8/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <bits/c++config.h>
                #include <new>
                #include <bits/functexcept.h>
                #include <bits/move.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  using std::size_t;
                  using std::ptrdiff_t;
                
                  /**
                   *  @brief  An allocator that uses global new, as per [20.4].
                   *  @ingroup allocators
                   *
                   *  This is precisely the allocator defined in the C++ Standard. 
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef new_allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. propagate_on_container_move_assignment
                      typedef std::true_type propagate_on_container_move_assignment;
                #endif
                
       80254 ->       new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
                
                      template<typename _Tp1>
                        new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
                
     1592285 ->       ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      pointer
                      address(reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      const_pointer
                      address(const_reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      pointer
                      allocate(size_type __n, const void* = 0)
                      { 
                	if (__n > this->max_size())
                	  std::__throw_bad_alloc();
                
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
     1839119 ->       deallocate(pointer __p, size_type)
                      { ::operator delete(__p); }
                
                      size_type
                      max_size() const _GLIBCXX_USE_NOEXCEPT
                      { return size_t(-1) / sizeof(_Tp); }
                
                #if __cplusplus >= 201103L
                      template<typename _Up, typename... _Args>
                        void
                        construct(_Up* __p, _Args&&... __args)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                        void 
                        destroy(_Up* __p) { __p->~_Up(); }
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void 
                      construct(pointer __p, const _Tp& __val) 
                      { ::new((void *)__p) _Tp(__val); }
                
                      void 
                      destroy(pointer __p) { __p->~_Tp(); }
                #endif
                    };
                
                  template<typename _Tp>
                    inline bool
                    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return true; }
                  
                  template<typename _Tp>
                    inline bool
                    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                    { return false; }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

      109    1839119
       86    1592285
       79      80254

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

  3511658   Total number of line executions
1170552.67   Average executions per line


*** File /home/niina/greens_functions/GreensFunction.hpp:
                #if !defined( __GREENSFUNCTION_HPP )
                #define __GREENSFUNCTION_HPP
                
                #include "Defs.hpp"
                namespace greens_functions{
                
                class GreensFunction
                {
                public:
                    enum EventKind
                    {
                        IV_ESCAPE,
                        IV_REACTION
                    };
                
                public:
          11 ->     GreensFunction( const Real D )
                      : D( D ) {}
                  
          11 ->     ~GreensFunction() {}
                  
                    Real getD() const
                    {
                        return this->D;
                    }
                
                protected:
                    const Real D;
                };
                
                }
                #endif // __GREENSFUNCTION_HPP


Top 10 Lines:

     Line      Count

       17         11
       20         11

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

       22   Total number of line executions
    11.00   Average executions per line


*** File /usr/include/c++/4.8/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                #include <bits/c++allocator.h> // Define the base class to std::allocator.
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup allocators
                   *  @{
                   */
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                      typedef void        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                #endif
                    };
                
                  /**
                   * @brief  The @a standard allocator, as per [20.4].
                   *
                   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html
                   *  for further details.
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class allocator: public __allocator_base<_Tp>
                    {
                   public:
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                      typedef _Tp        value_type;
                
                      template<typename _Tp1>
                        struct rebind
                        { typedef allocator<_Tp1> other; };
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      typedef true_type propagate_on_container_move_assignment;
                #endif
                
       70577 ->       allocator() throw() { }
                
                      allocator(const allocator& __a) throw()
                      : __allocator_base<_Tp>(__a) { }
                
                      template<typename _Tp1>
                        allocator(const allocator<_Tp1>&) throw() { }
                
     1582608 ->       ~allocator() throw() { }
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    { return true; }
                
                  template<typename _Tp>
                    inline bool
                    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
                    { return true; }
                
                  template<typename _T1, typename _T2>
                    inline bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    { return false; }
                
                  template<typename _Tp>
                    inline bool
                    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
                    { return false; }
                
                  /// @} group allocator
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __allocator_base
                
                  // To implement Option 3 of DR 431.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_swap
                    { static void _S_do_it(_Alloc&, _Alloc&) { } };
                
                  template<typename _Alloc>
                    struct __alloc_swap<_Alloc, false>
                    {
                      static void
                      _S_do_it(_Alloc& __one, _Alloc& __two)
                      {
                	// Precondition: swappable allocators.
                	if (__one != __two)
                	  swap(__one, __two);
                      }
                    };
                
                  // Optimize for stateless allocators.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_neq
                    {
                      static bool
                      _S_do_it(const _Alloc&, const _Alloc&)
                      { return false; }
                    };
                
                  template<typename _Alloc>
                    struct __alloc_neq<_Alloc, false>
                    {
                      static bool
                      _S_do_it(const _Alloc& __one, const _Alloc& __two)
                      { return __one != __two; }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, bool
                    = __or_<is_copy_constructible<typename _Tp::value_type>,
                            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
                    struct __shrink_to_fit_aux
                    { static bool _S_do_it(_Tp&) { return false; } };
                
                  template<typename _Tp>
                    struct __shrink_to_fit_aux<_Tp, true>
                    {
                      static bool
                      _S_do_it(_Tp& __c)
                      {
                	__try
                	  {
                	    _Tp(__make_move_if_noexcept_iterator(__c.begin()),
                		__make_move_if_noexcept_iterator(__c.end()),
                		__c.get_allocator()).swap(__c);
                	    return true;
                	  }
                	__catch(...)
                	  { return false; }
                      }
                    };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      121    1582608
      113      70577

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

  1653185   Total number of line executions
826592.50   Average executions per line


*** File /usr/include/boost/multi_array/extent_range.hpp:
                // Copyright 2002 The Trustees of Indiana University.
                
                // Use, modification and distribution is subject to the Boost Software 
                // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
                // http://www.boost.org/LICENSE_1_0.txt)
                
                //  Boost.MultiArray Library
                //  Authors: Ronald Garcia
                //           Jeremy Siek
                //           Andrew Lumsdaine
                //  See http://www.boost.org/libs/multi_array for documentation.
                
                #ifndef BOOST_EXTENT_RANGE_RG071801_HPP
                #define BOOST_EXTENT_RANGE_RG071801_HPP
                
                #include <utility>
                
                namespace boost {
                namespace detail {
                namespace multi_array {
                
                template <typename Extent, typename SizeType>
                class extent_range : private std::pair<Extent,Extent> {
                  typedef std::pair<Extent,Extent> super_type;
                public:
                  typedef Extent index;
                  typedef SizeType size_type;
                
                  extent_range(index start, index finish) :
                    super_type(start,finish) { }
                
                  extent_range(index finish) :
                    super_type(0,finish) { }
                
           2 ->   extent_range() : super_type(0,0) { }
                
                  index start() const { return super_type::first; }
                
                  index finish() const { return super_type::second; }
                
                  size_type size() const { return super_type::second - super_type::first; }
                };
                
                } // namespace multi_array
                } // namespace detail 
                } // namespace boost
                
                
                #endif // BOOST_EXTENT_RANGE_RG071801_HPP


Top 10 Lines:

     Line      Count

       35          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File /usr/include/boost/multi_array/extent_gen.hpp:
                // Copyright 2002 The Trustees of Indiana University.
                
                // Use, modification and distribution is subject to the Boost Software 
                // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
                // http://www.boost.org/LICENSE_1_0.txt)
                
                //  Boost.MultiArray Library
                //  Authors: Ronald Garcia
                //           Jeremy Siek
                //           Andrew Lumsdaine
                //  See http://www.boost.org/libs/multi_array for documentation.
                
                #ifndef BOOST_EXTENT_GEN_RG071801_HPP
                #define BOOST_EXTENT_GEN_RG071801_HPP
                
                #include "boost/multi_array/extent_range.hpp"
                #include "boost/multi_array/range_list.hpp"
                #include "boost/multi_array/types.hpp"
                #include "boost/array.hpp"
                #include <algorithm>
                
                namespace boost {
                namespace detail {
                namespace multi_array {
                
                
                template <std::size_t NumRanges>
                class extent_gen {
                public:
                  typedef boost::detail::multi_array::index index;
                  typedef boost::detail::multi_array::size_type size_type;
                  typedef extent_range<index,size_type> range;
                private:
                  typedef typename range_list_generator<range,NumRanges>::type range_list;
                public:
                  template <std::size_t Ranges>
                  struct gen_type {
                    typedef extent_gen<Ranges> type;
                  };
                
                  range_list ranges_;
                
           1 ->   extent_gen() { }
                
                  // Used by operator[] to expand extent_gens
                  extent_gen(const extent_gen<NumRanges-1>& rhs,
                            const range& a_range)
                  {
                    std::copy(rhs.ranges_.begin(),rhs.ranges_.end(),ranges_.begin());
                    *ranges_.rbegin() = a_range;
                  }
                
                  extent_gen<NumRanges+1>
                  operator[](const range& a_range)
                  {
                    return extent_gen<NumRanges+1>(*this,a_range);    
                  }
                
                  extent_gen<NumRanges+1>
                  operator[](index idx)
                  {
                    return extent_gen<NumRanges+1>(*this,range(0,idx));    
                  }    
                
                  static extent_gen<0> extents() {
                    return extent_gen<0>();
                  }
                };
                
                } // namespace multi_array
                } // namespace detail
                } // namespace boost
                
                
                #endif // BOOST_EXTENT_GEN_RG071801_HPP


Top 10 Lines:

     Line      Count

       43          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/boost/multi_array/index_range.hpp:
                // Copyright 2002 The Trustees of Indiana University.
                
                // Use, modification and distribution is subject to the Boost Software 
                // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
                // http://www.boost.org/LICENSE_1_0.txt)
                
                //  Boost.MultiArray Library
                //  Authors: Ronald Garcia
                //           Jeremy Siek
                //           Andrew Lumsdaine
                //  See http://www.boost.org/libs/multi_array for documentation.
                
                #ifndef BOOST_INDEX_RANGE_RG071801_HPP
                #define BOOST_INDEX_RANGE_RG071801_HPP
                
                #include <boost/config.hpp>
                #include <utility>
                #include <boost/limits.hpp>
                
                // For representing intervals, also with stride.
                // A degenerate range is a range with one element.
                
                // Thanks to Doug Gregor for the really cool idea of using the
                // comparison operators to express various interval types!
                
                // Internally, we represent the interval as half-open.
                
                namespace boost {
                namespace detail {
                namespace multi_array {
                
                  template <typename Index,typename SizeType>
                  class index_range {
                  public:
                    typedef Index index;
                    typedef SizeType size_type;
                
                  private:
           2 ->     static index from_start()
                      { return (std::numeric_limits<index>::min)(); }
                
           2 ->     static index to_end()
                      { return (std::numeric_limits<index>::max)(); }
                
                  public:
                
           2 ->     index_range()
                    {
                      start_ = from_start();
                      finish_ = to_end();
                      stride_ = 1;
                      degenerate_ = false;
                    }
                
                    explicit index_range(index pos)
                    {
                      start_ = pos;
                      finish_ = pos+1;
                      stride_ = 1;
                      degenerate_ = true;
                    }
                
                    explicit index_range(index start, index finish, index stride=1)
                      : start_(start), finish_(finish), stride_(stride),
                        degenerate_(false)
                    { }
                
                
                    // These are for chaining assignments to an index_range
                    index_range& start(index s) {
                      start_ = s;
                      degenerate_ = false;
                      return *this;
                    }
                
                    index_range& finish(index f) {
                      finish_ = f;
                      degenerate_ = false;
                      return *this;
                    }
                
                    index_range& stride(index s) { stride_ = s; return *this; }
                
                    index start() const
                    { 
                      return start_; 
                    }
                
                    index get_start(index low_index_range = index_range::from_start()) const
                    { 
                      if (start_ == from_start())
                        return low_index_range;
                      return start_; 
                    }
                
                    index finish() const
                    {
                      return finish_;
                    }
                
                    index get_finish(index high_index_range = index_range::to_end()) const
                    {
                      if (finish_ == to_end())
                        return high_index_range;
                      return finish_;
                    }
                
                    index stride() const { return stride_; }
                
                    void set_index_range(index start, index finish, index stride=1)
                    {
                      start_ = start;
                      finish_ = finish;
                      stride_ = stride;
                    }
                
                    static index_range all() 
                    { return index_range(from_start(), to_end(), 1); }
                
                    bool is_degenerate() const { return degenerate_; }
                
                    index_range operator-(index shift) const
                    { 
                      return index_range(start_ - shift, finish_ - shift, stride_); 
                    }
                
                    index_range operator+(index shift) const
                    { 
                      return index_range(start_ + shift, finish_ + shift, stride_); 
                    }
                
                    index operator[](unsigned i) const
                    {
                      return start_ + i * stride_;
                    }
                
                    index operator()(unsigned i) const
                    {
                      return start_ + i * stride_;
                    }
                
                    // add conversion to std::slice?
                
                  public:
                    index start_, finish_, stride_;
                    bool degenerate_;
                  };
                
                  // Express open and closed interval end-points using the comparison
                  // operators.
                
                  // left closed
                  template <typename Index, typename SizeType>
                  inline index_range<Index,SizeType>
                  operator<=(Index s, const index_range<Index,SizeType>& r)
                  {
                    return index_range<Index,SizeType>(s, r.finish(), r.stride());
                  }
                
                  // left open
                  template <typename Index, typename SizeType>
                  inline index_range<Index,SizeType>
                  operator<(Index s, const index_range<Index,SizeType>& r)
                  {
                    return index_range<Index,SizeType>(s + 1, r.finish(), r.stride());
                  }
                
                  // right open
                  template <typename Index, typename SizeType>
                  inline index_range<Index,SizeType>
                  operator<(const index_range<Index,SizeType>& r, Index f)
                  {
                    return index_range<Index,SizeType>(r.start(), f, r.stride());
                  }
                
                  // right closed
                  template <typename Index, typename SizeType>
                  inline index_range<Index,SizeType>
                  operator<=(const index_range<Index,SizeType>& r, Index f)
                  {
                    return index_range<Index,SizeType>(r.start(), f + 1, r.stride());
                  }
                
                } // namespace multi_array
                } // namespace detail  
                } // namespace boost
                
                #endif // BOOST_INDEX_RANGE_RG071801_HPP


Top 10 Lines:

     Line      Count

       39          2
       42          2
       47          2

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        6   Total number of line executions
     2.00   Average executions per line


*** File /usr/include/boost/multi_array/index_gen.hpp:
                // Copyright 2002 The Trustees of Indiana University.
                
                // Use, modification and distribution is subject to the Boost Software 
                // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
                // http://www.boost.org/LICENSE_1_0.txt)
                
                //  Boost.MultiArray Library
                //  Authors: Ronald Garcia
                //           Jeremy Siek
                //           Andrew Lumsdaine
                //  See http://www.boost.org/libs/multi_array for documentation.
                
                #ifndef BOOST_INDEX_GEN_RG071801_HPP
                #define BOOST_INDEX_GEN_RG071801_HPP
                
                #include "boost/array.hpp"
                #include "boost/multi_array/index_range.hpp"
                #include "boost/multi_array/range_list.hpp"
                #include "boost/multi_array/types.hpp"
                #include <algorithm> 
                #include <cstddef>
                
                namespace boost {
                namespace detail {
                namespace multi_array {
                
                
                template <int NumRanges, int NumDims>
                struct index_gen {
                private:
                  typedef ::boost::detail::multi_array::index index;
                  typedef ::boost::detail::multi_array::size_type size_type;
                  typedef index_range<index,size_type> range;
                public:
                  template <int Dims, int Ranges>
                  struct gen_type {
                    typedef index_gen<Ranges,Dims> type;
                  };
                
                  typedef typename range_list_generator<range,NumRanges>::type range_list;
                  range_list ranges_;
                
           1 ->   index_gen() { }
                
                  template <int ND>
                  explicit index_gen(const index_gen<NumRanges-1,ND>& rhs,
                            const range& r)
                  {
                    std::copy(rhs.ranges_.begin(),rhs.ranges_.end(),ranges_.begin());
                    *ranges_.rbegin() = r;
                  }
                
                  index_gen<NumRanges+1,NumDims+1>
                  operator[](const range& r) const
                  {
                    index_gen<NumRanges+1,NumDims+1> tmp;
                    std::copy(ranges_.begin(),ranges_.end(),tmp.ranges_.begin());
                    *tmp.ranges_.rbegin() = r;
                    return tmp;
                  }
                
                  index_gen<NumRanges+1,NumDims>
                  operator[](index idx) const
                  {
                    index_gen<NumRanges+1,NumDims> tmp;
                    std::copy(ranges_.begin(),ranges_.end(),tmp.ranges_.begin());
                    *tmp.ranges_.rbegin() = range(idx);
                    return tmp;
                  }    
                
                  static index_gen<0,0> indices() {
                    return index_gen<0,0>();
                  }
                };
                
                } // namespace multi_array
                } // namespace detail
                } // namespace boost
                
                
                #endif // BOOST_INDEX_GEN_RG071801_HPP


Top 10 Lines:

     Line      Count

       43          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /home/niina/greens_functions/GreensFunction2DAbsSym.hpp:
                #if !defined( __FIRSTPASSAGEGREENSFUNCTION2D_HPP )
                #define __FIRSTPASSAGEGREENSFUNCTION2D_HPP
                
                #include <vector>
                #include <boost/multi_array.hpp>
                
                #include "Defs.hpp"
                //#include "Logger.hpp"
                
                namespace greens_functions{
                
                class GreensFunction2DAbsSym
                {
                
                public:
                
           1 ->     GreensFunction2DAbsSym( const Real D, const Real a )
                	:
                	D( D ),
                        a( a )
                    {
                	;
                    }
                
           1 ->     virtual ~GreensFunction2DAbsSym()
                    {
                	;
                    }
                
                    const char* getName() const
                    {
                        return "GreensFunction2DAbsSym";
                    }
                
                    const Real getD() const
                    {
                	return this->D;
                    }
                
                    const Real geta() const
                    {
                        return this->a;
                    }
                
                    const Real p_survival( const Real t ) const; 
                
                    const Real drawTime( const Real rnd ) const;
                
                    const Real drawR( const Real rnd, const Real t ) const;
                
                    const Real p_int_r( const Real r, const Real t ) const;
                    const Real p_int_r_free( const Real r, const Real t ) const;
                
                    const std::string dump() const;
                
                // private methods
                private:
                
                    struct p_survival_params
                    {
                	const GreensFunction2DAbsSym* const gf;
                	const Real rnd;
                    };
                
                    static const Real p_survival_F( const Real t, 
                				    const p_survival_params* params );
                
                    struct p_r_params
                    {
                	const GreensFunction2DAbsSym* const gf;
                	const Real t;
                	const Real target;
                    };
                
                    static const Real p_r_free_F( const Real r, 
                                                  const p_r_params* params );
                
                    static const Real p_r_F( const Real r, 
                			     const p_r_params* params );
                
                // private variables
                private:
                
                    static const Real CUTOFF = 1e-10;
                
                    // H = 4.0: ~3e-5, 4.26: ~1e-6, 5.0: ~3e-7, 5.2: ~1e-7,
                    // 5.6: ~1e-8, 6.0: ~1e-9
                    static const Real CUTOFF_H = 6.0;
                
                    const Real D;
                
                    const Real a;
                    
                //    static Logger& log_;
                    
                };
                
                
                }
                #endif // __PAIRGREENSFUNCTION2D_HPP


Top 10 Lines:

     Line      Count

       17          1
       25          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/boost/math/tools/detail/rational_horner3_17.hpp:
                //  (C) Copyright John Maddock 2007.
                //  Use, modification and distribution are subject to the
                //  Boost Software License, Version 1.0. (See accompanying file
                //  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
                //
                //  This file is machine generated, do not edit by hand
                
                // Polynomial evaluation using second order Horners rule
                #ifndef BOOST_MATH_TOOLS_RAT_EVAL_17_HPP
                #define BOOST_MATH_TOOLS_RAT_EVAL_17_HPP
                
                namespace boost{ namespace math{ namespace tools{ namespace detail{
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T*, const U*, const V&, const mpl::int_<0>*)
                {
                   return static_cast<V>(0);
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V&, const mpl::int_<1>*)
                {
                   return static_cast<V>(a[0]) / static_cast<V>(b[0]);
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<2>*)
                {
                   return static_cast<V>((a[1] * x + a[0]) / (b[1] * x + b[0]));
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<3>*)
                {
                   return static_cast<V>(((a[2] * x + a[1]) * x + a[0]) / ((b[2] * x + b[1]) * x + b[0]));
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<4>*)
                {
                   return static_cast<V>((((a[3] * x + a[2]) * x + a[1]) * x + a[0]) / (((b[3] * x + b[2]) * x + b[1]) * x + b[0]));
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<5>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[4] * x2 + a[2];
                      t[1] = a[3] * x2 + a[1];
                      t[2] = b[4] * x2 + b[2];
                      t[3] = b[3] * x2 + b[1];
                      t[0] *= x2;
                      t[2] *= x2;
                      t[0] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[0]);
                      t[1] *= x;
                      t[3] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[2] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[2] += static_cast<V>(b[4]);
                      t[1] *= z;
                      t[3] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<6>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[5] * x2 + a[3];
                      t[1] = a[4] * x2 + a[2];
                      t[2] = b[5] * x2 + b[3];
                      t[3] = b[4] * x2 + b[2];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[1]);
                      t[1] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[1]);
                      t[3] += static_cast<V>(b[0]);
                      t[0] *= x;
                      t[2] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z;
                      t[2] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<7>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[6] * x2 + a[4];
                      t[1] = a[5] * x2 + a[3];
                      t[2] = b[6] * x2 + b[4];
                      t[3] = b[5] * x2 + b[3];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[2]);
                      t[1] += static_cast<V>(a[1]);
                      t[2] += static_cast<V>(b[2]);
                      t[3] += static_cast<V>(b[1]);
                      t[0] *= x2;
                      t[2] *= x2;
                      t[0] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[0]);
                      t[1] *= x;
                      t[3] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[2] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[2] += static_cast<V>(b[6]);
                      t[1] *= z;
                      t[3] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<8>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[7] * x2 + a[5];
                      t[1] = a[6] * x2 + a[4];
                      t[2] = b[7] * x2 + b[5];
                      t[3] = b[6] * x2 + b[4];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[3]);
                      t[1] += static_cast<V>(a[2]);
                      t[2] += static_cast<V>(b[3]);
                      t[3] += static_cast<V>(b[2]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[1]);
                      t[1] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[1]);
                      t[3] += static_cast<V>(b[0]);
                      t[0] *= x;
                      t[2] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z;
                      t[2] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<9>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[8] * x2 + a[6];
                      t[1] = a[7] * x2 + a[5];
                      t[2] = b[8] * x2 + b[6];
                      t[3] = b[7] * x2 + b[5];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[3]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[3]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[2]);
                      t[1] += static_cast<V>(a[1]);
                      t[2] += static_cast<V>(b[2]);
                      t[3] += static_cast<V>(b[1]);
                      t[0] *= x2;
                      t[2] *= x2;
                      t[0] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[0]);
                      t[1] *= x;
                      t[3] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[2] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[2] += static_cast<V>(b[8]);
                      t[1] *= z;
                      t[3] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<10>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[9] * x2 + a[7];
                      t[1] = a[8] * x2 + a[6];
                      t[2] = b[9] * x2 + b[7];
                      t[3] = b[8] * x2 + b[6];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[5]);
                      t[1] += static_cast<V>(a[4]);
                      t[2] += static_cast<V>(b[5]);
                      t[3] += static_cast<V>(b[4]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[3]);
                      t[1] += static_cast<V>(a[2]);
                      t[2] += static_cast<V>(b[3]);
                      t[3] += static_cast<V>(b[2]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[1]);
                      t[1] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[1]);
                      t[3] += static_cast<V>(b[0]);
                      t[0] *= x;
                      t[2] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= z;
                      t[2] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<11>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[10] * x2 + a[8];
                      t[1] = a[9] * x2 + a[7];
                      t[2] = b[10] * x2 + b[8];
                      t[3] = b[9] * x2 + b[7];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[3]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[3]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[2]);
                      t[1] += static_cast<V>(a[1]);
                      t[2] += static_cast<V>(b[2]);
                      t[3] += static_cast<V>(b[1]);
                      t[0] *= x2;
                      t[2] *= x2;
                      t[0] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[0]);
                      t[1] *= x;
                      t[3] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= z2;
                      t[2] *= z2;
                      t[0] += static_cast<V>(a[10]);
                      t[2] += static_cast<V>(b[10]);
                      t[1] *= z;
                      t[3] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<12>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[11] * x2 + a[9];
                      t[1] = a[10] * x2 + a[8];
                      t[2] = b[11] * x2 + b[9];
                      t[3] = b[10] * x2 + b[8];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[7]);
                      t[1] += static_cast<V>(a[6]);
                      t[2] += static_cast<V>(b[7]);
                      t[3] += static_cast<V>(b[6]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[5]);
                      t[1] += static_cast<V>(a[4]);
                      t[2] += static_cast<V>(b[5]);
                      t[3] += static_cast<V>(b[4]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[3]);
                      t[1] += static_cast<V>(a[2]);
                      t[2] += static_cast<V>(b[3]);
                      t[3] += static_cast<V>(b[2]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[1]);
                      t[1] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[1]);
                      t[3] += static_cast<V>(b[0]);
                      t[0] *= x;
                      t[2] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[10]);
                      t[1] += static_cast<V>(a[11]);
                      t[2] += static_cast<V>(b[10]);
                      t[3] += static_cast<V>(b[11]);
                      t[0] *= z;
                      t[2] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<13>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[12] * x2 + a[10];
                      t[1] = a[11] * x2 + a[9];
                      t[2] = b[12] * x2 + b[10];
                      t[3] = b[11] * x2 + b[9];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[3]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[3]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[2]);
                      t[1] += static_cast<V>(a[1]);
                      t[2] += static_cast<V>(b[2]);
                      t[3] += static_cast<V>(b[1]);
                      t[0] *= x2;
                      t[2] *= x2;
                      t[0] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[0]);
                      t[1] *= x;
                      t[3] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[10]);
                      t[1] += static_cast<V>(a[11]);
                      t[2] += static_cast<V>(b[10]);
                      t[3] += static_cast<V>(b[11]);
                      t[0] *= z2;
                      t[2] *= z2;
                      t[0] += static_cast<V>(a[12]);
                      t[2] += static_cast<V>(b[12]);
                      t[1] *= z;
                      t[3] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<14>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[13] * x2 + a[11];
                      t[1] = a[12] * x2 + a[10];
                      t[2] = b[13] * x2 + b[11];
                      t[3] = b[12] * x2 + b[10];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[9]);
                      t[1] += static_cast<V>(a[8]);
                      t[2] += static_cast<V>(b[9]);
                      t[3] += static_cast<V>(b[8]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[7]);
                      t[1] += static_cast<V>(a[6]);
                      t[2] += static_cast<V>(b[7]);
                      t[3] += static_cast<V>(b[6]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[5]);
                      t[1] += static_cast<V>(a[4]);
                      t[2] += static_cast<V>(b[5]);
                      t[3] += static_cast<V>(b[4]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[3]);
                      t[1] += static_cast<V>(a[2]);
                      t[2] += static_cast<V>(b[3]);
                      t[3] += static_cast<V>(b[2]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[1]);
                      t[1] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[1]);
                      t[3] += static_cast<V>(b[0]);
                      t[0] *= x;
                      t[2] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[10]);
                      t[1] += static_cast<V>(a[11]);
                      t[2] += static_cast<V>(b[10]);
                      t[3] += static_cast<V>(b[11]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[12]);
                      t[1] += static_cast<V>(a[13]);
                      t[2] += static_cast<V>(b[12]);
                      t[3] += static_cast<V>(b[13]);
                      t[0] *= z;
                      t[2] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<15>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[14] * x2 + a[12];
                      t[1] = a[13] * x2 + a[11];
                      t[2] = b[14] * x2 + b[12];
                      t[3] = b[13] * x2 + b[11];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[10]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[10]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[3]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[3]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[2]);
                      t[1] += static_cast<V>(a[1]);
                      t[2] += static_cast<V>(b[2]);
                      t[3] += static_cast<V>(b[1]);
                      t[0] *= x2;
                      t[2] *= x2;
                      t[0] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[0]);
                      t[1] *= x;
                      t[3] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[10]);
                      t[1] += static_cast<V>(a[11]);
                      t[2] += static_cast<V>(b[10]);
                      t[3] += static_cast<V>(b[11]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[12]);
                      t[1] += static_cast<V>(a[13]);
                      t[2] += static_cast<V>(b[12]);
                      t[3] += static_cast<V>(b[13]);
                      t[0] *= z2;
                      t[2] *= z2;
                      t[0] += static_cast<V>(a[14]);
                      t[2] += static_cast<V>(b[14]);
                      t[1] *= z;
                      t[3] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
                inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<16>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[15] * x2 + a[13];
                      t[1] = a[14] * x2 + a[12];
                      t[2] = b[15] * x2 + b[13];
                      t[3] = b[14] * x2 + b[12];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[11]);
                      t[1] += static_cast<V>(a[10]);
                      t[2] += static_cast<V>(b[11]);
                      t[3] += static_cast<V>(b[10]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[9]);
                      t[1] += static_cast<V>(a[8]);
                      t[2] += static_cast<V>(b[9]);
                      t[3] += static_cast<V>(b[8]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[7]);
                      t[1] += static_cast<V>(a[6]);
                      t[2] += static_cast<V>(b[7]);
                      t[3] += static_cast<V>(b[6]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[5]);
                      t[1] += static_cast<V>(a[4]);
                      t[2] += static_cast<V>(b[5]);
                      t[3] += static_cast<V>(b[4]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[3]);
                      t[1] += static_cast<V>(a[2]);
                      t[2] += static_cast<V>(b[3]);
                      t[3] += static_cast<V>(b[2]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[1]);
                      t[1] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[1]);
                      t[3] += static_cast<V>(b[0]);
                      t[0] *= x;
                      t[2] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[10]);
                      t[1] += static_cast<V>(a[11]);
                      t[2] += static_cast<V>(b[10]);
                      t[3] += static_cast<V>(b[11]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[12]);
                      t[1] += static_cast<V>(a[13]);
                      t[2] += static_cast<V>(b[12]);
                      t[3] += static_cast<V>(b[13]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[14]);
                      t[1] += static_cast<V>(a[15]);
                      t[2] += static_cast<V>(b[14]);
                      t[3] += static_cast<V>(b[15]);
                      t[0] *= z;
                      t[2] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                template <class T, class U, class V>
           2 -> inline V evaluate_rational_c_imp(const T* a, const U* b, const V& x, const mpl::int_<17>*)
                {
                   if(x <= 1)
                   {
                      V x2 = x * x;
                      V t[4];
                      t[0] = a[16] * x2 + a[14];
                      t[1] = a[15] * x2 + a[13];
                      t[2] = b[16] * x2 + b[14];
                      t[3] = b[15] * x2 + b[13];
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[12]);
                      t[1] += static_cast<V>(a[11]);
                      t[2] += static_cast<V>(b[12]);
                      t[3] += static_cast<V>(b[11]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[10]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[10]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[3]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[3]);
                      t[0] *= x2;
                      t[1] *= x2;
                      t[2] *= x2;
                      t[3] *= x2;
                      t[0] += static_cast<V>(a[2]);
                      t[1] += static_cast<V>(a[1]);
                      t[2] += static_cast<V>(b[2]);
                      t[3] += static_cast<V>(b[1]);
                      t[0] *= x2;
                      t[2] *= x2;
                      t[0] += static_cast<V>(a[0]);
                      t[2] += static_cast<V>(b[0]);
                      t[1] *= x;
                      t[3] *= x;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                   else
                   {
                      V z = 1 / x;
                      V z2 = 1 / (x * x);
                      V t[4];
                      t[0] = a[0] * z2 + a[2];
                      t[1] = a[1] * z2 + a[3];
                      t[2] = b[0] * z2 + b[2];
                      t[3] = b[1] * z2 + b[3];
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[4]);
                      t[1] += static_cast<V>(a[5]);
                      t[2] += static_cast<V>(b[4]);
                      t[3] += static_cast<V>(b[5]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[6]);
                      t[1] += static_cast<V>(a[7]);
                      t[2] += static_cast<V>(b[6]);
                      t[3] += static_cast<V>(b[7]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[8]);
                      t[1] += static_cast<V>(a[9]);
                      t[2] += static_cast<V>(b[8]);
                      t[3] += static_cast<V>(b[9]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[10]);
                      t[1] += static_cast<V>(a[11]);
                      t[2] += static_cast<V>(b[10]);
                      t[3] += static_cast<V>(b[11]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[12]);
                      t[1] += static_cast<V>(a[13]);
                      t[2] += static_cast<V>(b[12]);
                      t[3] += static_cast<V>(b[13]);
                      t[0] *= z2;
                      t[1] *= z2;
                      t[2] *= z2;
                      t[3] *= z2;
                      t[0] += static_cast<V>(a[14]);
                      t[1] += static_cast<V>(a[15]);
                      t[2] += static_cast<V>(b[14]);
                      t[3] += static_cast<V>(b[15]);
                      t[0] *= z2;
                      t[2] *= z2;
                      t[0] += static_cast<V>(a[16]);
                      t[2] += static_cast<V>(b[16]);
                      t[1] *= z;
                      t[3] *= z;
                      return (t[0] + t[1]) / (t[2] + t[3]);
                   }
                }
                
                
                }}}} // namespaces
                
                #endif // include guard
                


Top 10 Lines:

     Line      Count

     1029          2

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     2.00   Average executions per line


*** File /home/niina/greens_functions/GreensFunction3DAbsSym.hpp:
                #if !defined( __FIRSTPASSAGEGREENSFUNCTION_HPP)
                #define __FIRSTPASSAGEGREENSFUNCTION_HPP
                
                #include "Defs.hpp"
                //#include "Logger.hpp"
                #include "GreensFunction.hpp"
                #include <ostream>
                
                namespace greens_functions{
                
                class GreensFunction3DAbsSym: public GreensFunction
                {
                public:
           1 ->     GreensFunction3DAbsSym(Real D, Real a)
                        : GreensFunction(D), a(a) {}
                
           1 ->     ~GreensFunction3DAbsSym() {}
                
                    Real getD() const
                    {
                        return this->D;
                    }
                
                    Real geta() const
                    {
                        return this->a;
                    }
                
                    Real p_survival(Real t) const; 
                
                    Real drawTime(Real rnd) const;
                
                    Real drawR(Real rnd, Real t) const;
                
                    Real p_int_r(Real r, Real t) const;
                    Real p_int_r_free(Real r, Real t) const;
                
                    Real p_r_fourier(Real r, Real t) const;
                	
                    std::string dump() const;
                
                    const char* getName() const
                    {
                        return "GreensFunction3DAbsSym";
                    }
                
                private:
                    static Real ellipticTheta4Zero(Real q);
                
                private:
                
                    static const Real CUTOFF = 1e-10;
                
                    // H = 4.0: ~3e-5, 4.26: ~1e-6, 5.0: ~3e-7, 5.2: ~1e-7,
                    // 5.6: ~1e-8, 6.0: ~1e-9
                    static const Real CUTOFF_H = 6.0;
                
                    const Real a;
                
                //    static Logger& log_;
                };
                
                template<typename Tstrm, typename Ttraits>
                inline std::basic_ostream<Tstrm, Ttraits>&
                operator <<(std::basic_ostream<Tstrm, Ttraits>& strm,
                            GreensFunction3DAbsSym const& gf)
                {
                    strm << "GreensFunction3DAbsSym("
                         << "D=" << gf.getD() << ", "
                         << "a=" << gf.geta() << ")";
                    return strm;
                }
                
                }
                #endif // __PAIRGREENSFUNCTION_HPP


Top 10 Lines:

     Line      Count

       14          1
       17          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/boost/math/special_functions/lanczos.hpp:
                //  (C) Copyright John Maddock 2006.
                //  Use, modification and distribution are subject to the
                //  Boost Software License, Version 1.0. (See accompanying file
                //  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
                
                #ifndef BOOST_MATH_SPECIAL_FUNCTIONS_LANCZOS
                #define BOOST_MATH_SPECIAL_FUNCTIONS_LANCZOS
                
                #ifdef _MSC_VER
                #pragma once
                #endif
                
                #include <boost/config.hpp>
                #include <boost/math/tools/big_constant.hpp>
                #include <boost/mpl/if.hpp>
                #include <boost/limits.hpp>
                #include <boost/cstdint.hpp>
                #include <boost/math/tools/rational.hpp>
                #include <boost/math/policies/policy.hpp>
                #include <boost/mpl/less_equal.hpp>
                
                #include <limits.h>
                
                namespace boost{ namespace math{ namespace lanczos{
                
                //
                // Individual lanczos approximations start here.
                //
                // Optimal values for G for each N are taken from
                // http://web.mala.bc.ca/pughg/phdThesis/phdThesis.pdf,
                // as are the theoretical error bounds.
                //
                // Constants calculated using the method described by Godfrey
                // http://my.fit.edu/~gabdo/gamma.txt and elaborated by Toth at
                // http://www.rskey.org/gamma.htm using NTL::RR at 1000 bit precision.
                //
                // Begin with a small helper to force initialization of constants prior
                // to main.  This makes the constant initialization thread safe, even
                // when called with a user-defined number type.
                //
                template <class Lanczos, class T>
                struct lanczos_initializer
                {
                   struct init
                   {
           1 ->       init()
                      {
                         T t(1);
                         Lanczos::lanczos_sum(t);
                         Lanczos::lanczos_sum_expG_scaled(t);
                         Lanczos::lanczos_sum_near_1(t);
                         Lanczos::lanczos_sum_near_2(t);
                         Lanczos::g();
                      }
           4 ->       void force_instantiate()const{}
                   };
                   static const init initializer;
           4 ->    static void force_instantiate()
                   {
                      initializer.force_instantiate();
                   }
                };
                template <class Lanczos, class T>
                typename lanczos_initializer<Lanczos, T>::init const lanczos_initializer<Lanczos, T>::initializer;
                //
                // Lanczos Coefficients for N=6 G=5.581
                // Max experimental error (with arbitary precision arithmetic) 9.516e-12
                // Generated with compiler: Microsoft Visual C++ version 8.0 on Win32 at Mar 23 2006
                //
                struct lanczos6 : public mpl::int_<35>
                {
                   //
                   // Produces slightly better than float precision when evaluated at
                   // double precision:
                   //
                   template <class T>
                   static T lanczos_sum(const T& z)
                   {
                      lanczos_initializer<lanczos6, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[6] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 8706.349592549009182288174442774377925882)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 8523.650341121874633477483696775067709735)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 3338.029219476423550899999750161289306564)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 653.6424994294008795995653541449610986791)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 63.99951844938187085666201263218840287667)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 2.506628274631006311133031631822390264407))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint16_t) denom[6] = {
                         static_cast<boost::uint16_t>(0u),
                         static_cast<boost::uint16_t>(24u),
                         static_cast<boost::uint16_t>(50u),
                         static_cast<boost::uint16_t>(35u),
                         static_cast<boost::uint16_t>(10u),
                         static_cast<boost::uint16_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                   template <class T>
                   static T lanczos_sum_expG_scaled(const T& z)
                   {
                      lanczos_initializer<lanczos6, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[6] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 32.81244541029783471623665933780748627823)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 32.12388941444332003446077108933558534361)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 12.58034729455216106950851080138931470954)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 2.463444478353241423633780693218408889251)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 0.2412010548258800231126240760264822486599)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 0.009446967704539249494420221613134244048319))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint16_t) denom[6] = {
                         static_cast<boost::uint16_t>(0u),
                         static_cast<boost::uint16_t>(24u),
                         static_cast<boost::uint16_t>(50u),
                         static_cast<boost::uint16_t>(35u),
                         static_cast<boost::uint16_t>(10u),
                         static_cast<boost::uint16_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                
                   template<class T>
                   static T lanczos_sum_near_1(const T& dz)
                   {
                      lanczos_initializer<lanczos6, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[5] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 2.044879010930422922760429926121241330235)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, -2.751366405578505366591317846728753993668)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 1.02282965224225004296750609604264824677)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, -0.09786124911582813985028889636665335893627)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 0.0009829742267506615183144364420540766510112)),
                      };
                      T result = 0;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(k*dz + k*k);
                      }
                      return result;
                   }
                
                   template<class T>
                   static T lanczos_sum_near_2(const T& dz)
                   {
                      lanczos_initializer<lanczos6, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[5] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 5.748142489536043490764289256167080091892)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, -7.734074268282457156081021756682138251825)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 2.875167944990511006997713242805893543947)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, -0.2750873773533504542306766137703788781776)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 35, 0.002763134585812698552178368447708846850353)),
                      };
                      T result = 0;
                      T z = dz + 2;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(z + k*z + k*k - 1);
                      }
                      return result;
                   }
                
                   static double g(){ return 5.581000000000000405009359383257105946541; }
                };
                
                //
                // Lanczos Coefficients for N=11 G=10.900511
                // Max experimental error (with arbitary precision arithmetic) 2.16676e-19
                // Generated with compiler: Microsoft Visual C++ version 8.0 on Win32 at Mar 23 2006
                //
                struct lanczos11 : public mpl::int_<60>
                {
                   //
                   // Produces slightly better than double precision when evaluated at
                   // extended-double precision:
                   //
                   template <class T>
                   static T lanczos_sum(const T& z)
                   {
                      lanczos_initializer<lanczos11, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[11] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 38474670393.31776828316099004518914832218)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 36857665043.51950660081971227404959150474)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 15889202453.72942008945006665994637853242)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 4059208354.298834770194507810788393801607)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 680547661.1834733286087695557084801366446)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 78239755.00312005289816041245285376206263)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 6246580.776401795264013335510453568106366)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 341986.3488721347032223777872763188768288)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 12287.19451182455120096222044424100527629)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 261.6140441641668190791708576058805625502)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 2.506628274631000502415573855452633787834))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint32_t) denom[11] = {
                         static_cast<boost::uint32_t>(0u),
                         static_cast<boost::uint32_t>(362880u),
                         static_cast<boost::uint32_t>(1026576u),
                         static_cast<boost::uint32_t>(1172700u),
                         static_cast<boost::uint32_t>(723680u),
                         static_cast<boost::uint32_t>(269325u),
                         static_cast<boost::uint32_t>(63273u),
                         static_cast<boost::uint32_t>(9450u),
                         static_cast<boost::uint32_t>(870u),
                         static_cast<boost::uint32_t>(45u),
                         static_cast<boost::uint32_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                   template <class T>
                   static T lanczos_sum_expG_scaled(const T& z)
                   {
                      lanczos_initializer<lanczos11, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[11] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 709811.662581657956893540610814842699825)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 679979.847415722640161734319823103390728)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 293136.785721159725251629480984140341656)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 74887.5403291467179935942448101441897121)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 12555.29058241386295096255111537516768137)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 1443.42992444170669746078056942194198252)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 115.2419459613734722083208906727972935065)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 6.30923920573262762719523981992008976989)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 0.2266840463022436475495508977579735223818)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 0.004826466289237661857584712046231435101741)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 0.4624429436045378766270459638520555557321e-4))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint32_t) denom[11] = {
                         static_cast<boost::uint32_t>(0u),
                         static_cast<boost::uint32_t>(362880u),
                         static_cast<boost::uint32_t>(1026576u),
                         static_cast<boost::uint32_t>(1172700u),
                         static_cast<boost::uint32_t>(723680u),
                         static_cast<boost::uint32_t>(269325u),
                         static_cast<boost::uint32_t>(63273u),
                         static_cast<boost::uint32_t>(9450u),
                         static_cast<boost::uint32_t>(870u),
                         static_cast<boost::uint32_t>(45u),
                         static_cast<boost::uint32_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                
                   template<class T>
                   static T lanczos_sum_near_1(const T& dz)
                   {
                      lanczos_initializer<lanczos11, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[10] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 4.005853070677940377969080796551266387954)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -13.17044315127646469834125159673527183164)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 17.19146865350790353683895137079288129318)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -11.36446409067666626185701599196274701126)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 4.024801119349323770107694133829772634737)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -0.7445703262078094128346501724255463005006)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 0.06513861351917497265045550019547857713172)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -0.00217899958561830354633560009312512312758)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 0.17655204574495137651670832229571934738e-4)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -0.1036282091079938047775645941885460820853e-7)),
                      };
                      T result = 0;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(k*dz + k*k);
                      }
                      return result;
                   }
                
                   template<class T>
                   static T lanczos_sum_near_2(const T& dz)
                   {
                      lanczos_initializer<lanczos11, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[10] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 19.05889633808148715159575716844556056056)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -62.66183664701721716960978577959655644762)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 81.7929198065004751699057192860287512027)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -54.06941772964234828416072865069196553015)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 19.14904664790693019642068229478769661515)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -3.542488556926667589704590409095331790317)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 0.3099140334815639910894627700232804503017)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -0.01036716187296241640634252431913030440825)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, 0.8399926504443119927673843789048514017761e-4)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 60, -0.493038376656195010308610694048822561263e-7)),
                      };
                      T result = 0;
                      T z = dz + 2;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(z + k*z + k*k - 1);
                      }
                      return result;
                   }
                
                   static double g(){ return 10.90051099999999983936049829935654997826; }
                };
                
                //
                // Lanczos Coefficients for N=13 G=13.144565
                // Max experimental error (with arbitary precision arithmetic) 9.2213e-23
                // Generated with compiler: Microsoft Visual C++ version 8.0 on Win32 at Mar 23 2006
                //
                struct lanczos13 : public mpl::int_<72>
                {
                   //
                   // Produces slightly better than extended-double precision when evaluated at
                   // higher precision:
                   //
                   template <class T>
                   static T lanczos_sum(const T& z)
                   {
                      lanczos_initializer<lanczos13, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[13] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 44012138428004.60895436261759919070125699)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 41590453358593.20051581730723108131357995)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 18013842787117.99677796276038389462742949)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 4728736263475.388896889723995205703970787)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 837910083628.4046470415724300225777912264)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 105583707273.4299344907359855510105321192)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 9701363618.494999493386608345339104922694)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 654914397.5482052641016767125048538245644)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 32238322.94213356530668889463945849409184)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 1128514.219497091438040721811544858643121)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 26665.79378459858944762533958798805525125)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 381.8801248632926870394389468349331394196)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 2.506628274631000502415763426076722427007))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint32_t) denom[13] = {
                         static_cast<boost::uint32_t>(0u),
                         static_cast<boost::uint32_t>(39916800u),
                         static_cast<boost::uint32_t>(120543840u),
                         static_cast<boost::uint32_t>(150917976u),
                         static_cast<boost::uint32_t>(105258076u),
                         static_cast<boost::uint32_t>(45995730u),
                         static_cast<boost::uint32_t>(13339535u),
                         static_cast<boost::uint32_t>(2637558u),
                         static_cast<boost::uint32_t>(357423u),
                         static_cast<boost::uint32_t>(32670u),
                         static_cast<boost::uint32_t>(1925u),
                         static_cast<boost::uint32_t>(66u),
                         static_cast<boost::uint32_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                   template <class T>
                   static T lanczos_sum_expG_scaled(const T& z)
                   {
                      lanczos_initializer<lanczos13, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[13] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 86091529.53418537217994842267760536134841)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 81354505.17858011242874285785316135398567)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 35236626.38815461910817650960734605416521)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 9249814.988024471294683815872977672237195)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 1639024.216687146960253839656643518985826)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 206530.8157641225032631778026076868855623)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 18976.70193530288915698282139308582105936)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 1281.068909912559479885759622791374106059)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 63.06093343420234536146194868906771599354)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 2.207470909792527638222674678171050209691)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 0.05216058694613505427476207805814960742102)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 0.0007469903808915448316510079585999893674101)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 0.4903180573459871862552197089738373164184e-5))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint32_t) denom[13] = {
                         static_cast<boost::uint32_t>(0u),
                         static_cast<boost::uint32_t>(39916800u),
                         static_cast<boost::uint32_t>(120543840u),
                         static_cast<boost::uint32_t>(150917976u),
                         static_cast<boost::uint32_t>(105258076u),
                         static_cast<boost::uint32_t>(45995730u),
                         static_cast<boost::uint32_t>(13339535u),
                         static_cast<boost::uint32_t>(2637558u),
                         static_cast<boost::uint32_t>(357423u),
                         static_cast<boost::uint32_t>(32670u),
                         static_cast<boost::uint32_t>(1925u),
                         static_cast<boost::uint32_t>(66u),
                         static_cast<boost::uint32_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                
                   template<class T>
                   static T lanczos_sum_near_1(const T& dz)
                   {
                      lanczos_initializer<lanczos13, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[12] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 4.832115561461656947793029596285626840312)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -19.86441536140337740383120735104359034688)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 33.9927422807443239927197864963170585331)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -31.41520692249765980987427413991250886138)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 17.0270866009599345679868972409543597821)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -5.5077216950865501362506920516723682167)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 1.037811741948214855286817963800439373362)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -0.106640468537356182313660880481398642811)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 0.005276450526660653288757565778182586742831)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -0.0001000935625597121545867453746252064770029)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 0.462590910138598083940803704521211569234e-6)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -0.1735307814426389420248044907765671743012e-9)),
                      };
                      T result = 0;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(k*dz + k*k);
                      }
                      return result;
                   }
                
                   template<class T>
                   static T lanczos_sum_near_2(const T& dz)
                   {
                      lanczos_initializer<lanczos13, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[12] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 26.96979819614830698367887026728396466395)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -110.8705424709385114023884328797900204863)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 189.7258846119231466417015694690434770085)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -175.3397202971107486383321670769397356553)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 95.03437648691551457087250340903980824948)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -30.7406022781665264273675797983497141978)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 5.792405601630517993355102578874590410552)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -0.5951993240669148697377539518639997795831)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 0.02944979359164017509944724739946255067671)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -0.0005586586555377030921194246330399163602684)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, 0.2581888478270733025288922038673392636029e-5)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 72, -0.9685385411006641478305219367315965391289e-9)),
                      };
                      T result = 0;
                      T z = dz + 2;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(z + k*z + k*k - 1);
                      }
                      return result;
                   }
                
                   static double g(){ return 13.1445650000000000545696821063756942749; }
                };
                
                //
                // Lanczos Coefficients for N=22 G=22.61891
                // Max experimental error (with arbitary precision arithmetic) 2.9524e-38
                // Generated with compiler: Microsoft Visual C++ version 8.0 on Win32 at Mar 23 2006
                //
                struct lanczos22 : public mpl::int_<120>
                {
                   //
                   // Produces slightly better than 128-bit long-double precision when 
                   // evaluated at higher precision:
                   //
                   template <class T>
                   static T lanczos_sum(const T& z)
                   {
                      lanczos_initializer<lanczos22, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[22] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 46198410803245094237463011094.12173081986)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 43735859291852324413622037436.321513777)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 19716607234435171720534556386.97481377748)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 5629401471315018442177955161.245623932129)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 1142024910634417138386281569.245580222392)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 175048529315951173131586747.695329230778)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 21044290245653709191654675.41581372963167)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 2033001410561031998451380.335553678782601)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 160394318862140953773928.8736211601848891)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 10444944438396359705707.48957290388740896)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 565075825801617290121.1466393747967538948)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 25475874292116227538.99448534450411942597)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 957135055846602154.6720835535232270205725)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 29874506304047462.23662392445173880821515)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 769651310384737.2749087590725764959689181)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 16193289100889.15989633624378404096011797)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 273781151680.6807433264462376754578933261)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 3630485900.32917021712188739762161583295)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 36374352.05577334277856865691538582936484)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 258945.7742115532455441786924971194951043)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 1167.501919472435718934219997431551246996)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 2.50662827463100050241576528481104525333))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint64_t) denom[22] = {
                         BOOST_MATH_INT_VALUE_SUFFIX(0, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(2432902008176640000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(8752948036761600000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(13803759753640704000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(12870931245150988800, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(8037811822645051776, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(3599979517947607200, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1206647803780373360, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(311333643161390640, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(63030812099294896, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(10142299865511450, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1307535010540395, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(135585182899530, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(11310276995381, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(756111184500, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(40171771630, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1672280820, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(53327946, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1256850, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(20615, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(210, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1, uLL)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                   template <class T>
                   static T lanczos_sum_expG_scaled(const T& z)
                   {
                      lanczos_initializer<lanczos22, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[22] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 6939996264376682180.277485395074954356211)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 6570067992110214451.87201438870245659384)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 2961859037444440551.986724631496417064121)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 845657339772791245.3541226499766163431651)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 171556737035449095.2475716923888737881837)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 26296059072490867.7822441885603400926007)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 3161305619652108.433798300149816829198706)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 305400596026022.4774396904484542582526472)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 24094681058862.55120507202622377623528108)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 1569055604375.919477574824168939428328839)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 84886558909.02047889339710230696942513159)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 3827024985.166751989686050643579753162298)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 143782298.9273215199098728674282885500522)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 4487794.24541641841336786238909171265944)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 115618.2025760830513505888216285273541959)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 2432.580773108508276957461757328744780439)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 41.12782532742893597168530008461874360191)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.5453771709477689805460179187388702295792)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.005464211062612080347167337964166505282809)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.388992321263586767037090706042788910953e-4)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.1753839324538447655939518484052327068859e-6)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.3765495513732730583386223384116545391759e-9))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint64_t) denom[22] = {
                         BOOST_MATH_INT_VALUE_SUFFIX(0, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(2432902008176640000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(8752948036761600000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(13803759753640704000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(12870931245150988800, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(8037811822645051776, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(3599979517947607200, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1206647803780373360, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(311333643161390640, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(63030812099294896, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(10142299865511450, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1307535010540395, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(135585182899530, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(11310276995381, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(756111184500, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(40171771630, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1672280820, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(53327946, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1256850, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(20615, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(210, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1, uLL)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                
                   template<class T>
                   static T lanczos_sum_near_1(const T& dz)
                   {
                      lanczos_initializer<lanczos22, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[21] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 8.318998691953337183034781139546384476554)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -63.15415991415959158214140353299240638675)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 217.3108224383632868591462242669081540163)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -448.5134281386108366899784093610397354889)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 619.2903759363285456927248474593012711346)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -604.1630177420625418522025080080444177046)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 428.8166750424646119935047118287362193314)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -224.6988753721310913866347429589434550302)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 87.32181627555510833499451817622786940961)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -25.07866854821128965662498003029199058098)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 5.264398125689025351448861011657789005392)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.792518936256495243383586076579921559914)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.08317448364744713773350272460937904691566)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.005845345166274053157781068150827567998882)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.0002599412126352082483326238522490030412391)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.6748102079670763884917431338234783496303e-5)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.908824383434109002762325095643458603605e-7)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.5299325929309389890892469299969669579725e-9)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.994306085859549890267983602248532869362e-12)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.3499893692975262747371544905820891835298e-15)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.7260746353663365145454867069182884694961e-20)),
                      };
                      T result = 0;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(k*dz + k*k);
                      }
                      return result;
                   }
                
                   template<class T>
                   static T lanczos_sum_near_2(const T& dz)
                   {
                      lanczos_initializer<lanczos22, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[21] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 75.39272007105208086018421070699575462226)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -572.3481967049935412452681346759966390319)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 1969.426202741555335078065370698955484358)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -4064.74968778032030891520063865996757519)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 5612.452614138013929794736248384309574814)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -5475.357667500026172903620177988213902339)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 3886.243614216111328329547926490398103492)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -2036.382026072125407192448069428134470564)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 791.3727954936062108045551843636692287652)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -227.2808432388436552794021219198885223122)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 47.70974355562144229897637024320739257284)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -7.182373807798293545187073539819697141572)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.7537866989631514559601547530490976100468)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.05297470142240154822658739758236594717787)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.00235577330936380542539812701472320434133)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.6115613067659273118098229498679502138802e-4)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.8236417010170941915758315020695551724181e-6)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.4802628430993048190311242611330072198089e-8)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.9011113376981524418952720279739624707342e-11)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, -0.3171854152689711198382455703658589996796e-14)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 120, 0.6580207998808093935798753964580596673177e-19)),
                      };
                      T result = 0;
                      T z = dz + 2;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(z + k*z + k*k - 1);
                      }
                      return result;
                   }
                
                   static double g(){ return 22.61890999999999962710717227309942245483; }
                };
                
                //
                // Lanczos Coefficients for N=6 G=1.428456135094165802001953125
                // Max experimental error (with arbitary precision arithmetic) 8.111667e-8
                // Generated with compiler: Microsoft Visual C++ version 8.0 on Win32 at Mar 23 2006
                //
                struct lanczos6m24 : public mpl::int_<24>
                {
                   //
                   // Use for float precision, when evaluated as a float:
                   //
                   template <class T>
                   static T lanczos_sum(const T& z)
                   {
                      static const T num[6] = {
                         static_cast<T>(58.52061591769095910314047740215847630266L),
                         static_cast<T>(182.5248962595894264831189414768236280862L),
                         static_cast<T>(211.0971093028510041839168287718170827259L),
                         static_cast<T>(112.2526547883668146736465390902227161763L),
                         static_cast<T>(27.5192015197455403062503721613097825345L),
                         static_cast<T>(2.50662858515256974113978724717473206342L)
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint16_t) denom[6] = {
                         static_cast<boost::uint16_t>(0u),
                         static_cast<boost::uint16_t>(24u),
                         static_cast<boost::uint16_t>(50u),
                         static_cast<boost::uint16_t>(35u),
                         static_cast<boost::uint16_t>(10u),
                         static_cast<boost::uint16_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                   template <class T>
                   static T lanczos_sum_expG_scaled(const T& z)
                   {
                      static const T num[6] = {
                         static_cast<T>(14.0261432874996476619570577285003839357L),
                         static_cast<T>(43.74732405540314316089531289293124360129L),
                         static_cast<T>(50.59547402616588964511581430025589038612L),
                         static_cast<T>(26.90456680562548195593733429204228910299L),
                         static_cast<T>(6.595765571169314946316366571954421695196L),
                         static_cast<T>(0.6007854010515290065101128585795542383721L)
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint16_t) denom[6] = {
                         static_cast<boost::uint16_t>(0u),
                         static_cast<boost::uint16_t>(24u),
                         static_cast<boost::uint16_t>(50u),
                         static_cast<boost::uint16_t>(35u),
                         static_cast<boost::uint16_t>(10u),
                         static_cast<boost::uint16_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                
                   template<class T>
                   static T lanczos_sum_near_1(const T& dz)
                   {
                      static const T d[5] = {
                         static_cast<T>(0.4922488055204602807654354732674868442106L),
                         static_cast<T>(0.004954497451132152436631238060933905650346L),
                         static_cast<T>(-0.003374784572167105840686977985330859371848L),
                         static_cast<T>(0.001924276018962061937026396537786414831385L),
                         static_cast<T>(-0.00056533046336427583708166383712907694434L),
                      };
                      T result = 0;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(k*dz + k*k);
                      }
                      return result;
                   }
                
                   template<class T>
                   static T lanczos_sum_near_2(const T& dz)
                   {
                      static const T d[5] = {
                         static_cast<T>(0.6534966888520080645505805298901130485464L),
                         static_cast<T>(0.006577461728560758362509168026049182707101L),
                         static_cast<T>(-0.004480276069269967207178373559014835978161L),
                         static_cast<T>(0.00255461870648818292376982818026706528842L),
                         static_cast<T>(-0.000750517993690428370380996157470900204524L),
                      };
                      T result = 0;
                      T z = dz + 2;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(z + k*z + k*k - 1);
                      }
                      return result;
                   }
                
                   static double g(){ return 1.428456135094165802001953125; }
                };
                
                //
                // Lanczos Coefficients for N=13 G=6.024680040776729583740234375
                // Max experimental error (with arbitary precision arithmetic) 1.196214e-17
                // Generated with compiler: Microsoft Visual C++ version 8.0 on Win32 at Mar 23 2006
                //
                struct lanczos13m53 : public mpl::int_<53>
                {
                   //
                   // Use for double precision, when evaluated as a double:
                   //
                   template <class T>
                   static T lanczos_sum(const T& z)
                   {
                      static const T num[13] = {
                         static_cast<T>(23531376880.41075968857200767445163675473L),
                         static_cast<T>(42919803642.64909876895789904700198885093L),
                         static_cast<T>(35711959237.35566804944018545154716670596L),
                         static_cast<T>(17921034426.03720969991975575445893111267L),
                         static_cast<T>(6039542586.35202800506429164430729792107L),
                         static_cast<T>(1439720407.311721673663223072794912393972L),
                         static_cast<T>(248874557.8620541565114603864132294232163L),
                         static_cast<T>(31426415.58540019438061423162831820536287L),
                         static_cast<T>(2876370.628935372441225409051620849613599L),
                         static_cast<T>(186056.2653952234950402949897160456992822L),
                         static_cast<T>(8071.672002365816210638002902272250613822L),
                         static_cast<T>(210.8242777515793458725097339207133627117L),
                         static_cast<T>(2.506628274631000270164908177133837338626L)
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint32_t) denom[13] = {
                         static_cast<boost::uint32_t>(0u),
                         static_cast<boost::uint32_t>(39916800u),
                         static_cast<boost::uint32_t>(120543840u),
                         static_cast<boost::uint32_t>(150917976u),
                         static_cast<boost::uint32_t>(105258076u),
                         static_cast<boost::uint32_t>(45995730u),
                         static_cast<boost::uint32_t>(13339535u),
                         static_cast<boost::uint32_t>(2637558u),
                         static_cast<boost::uint32_t>(357423u),
                         static_cast<boost::uint32_t>(32670u),
                         static_cast<boost::uint32_t>(1925u),
                         static_cast<boost::uint32_t>(66u),
                         static_cast<boost::uint32_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                   template <class T>
                   static T lanczos_sum_expG_scaled(const T& z)
                   {
                      static const T num[13] = {
                         static_cast<T>(56906521.91347156388090791033559122686859L),
                         static_cast<T>(103794043.1163445451906271053616070238554L),
                         static_cast<T>(86363131.28813859145546927288977868422342L),
                         static_cast<T>(43338889.32467613834773723740590533316085L),
                         static_cast<T>(14605578.08768506808414169982791359218571L),
                         static_cast<T>(3481712.15498064590882071018964774556468L),
                         static_cast<T>(601859.6171681098786670226533699352302507L),
                         static_cast<T>(75999.29304014542649875303443598909137092L),
                         static_cast<T>(6955.999602515376140356310115515198987526L),
                         static_cast<T>(449.9445569063168119446858607650988409623L),
                         static_cast<T>(19.51992788247617482847860966235652136208L),
                         static_cast<T>(0.5098416655656676188125178644804694509993L),
                         static_cast<T>(0.006061842346248906525783753964555936883222L)
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint32_t) denom[13] = {
                         static_cast<boost::uint32_t>(0u),
                         static_cast<boost::uint32_t>(39916800u),
                         static_cast<boost::uint32_t>(120543840u),
                         static_cast<boost::uint32_t>(150917976u),
                         static_cast<boost::uint32_t>(105258076u),
                         static_cast<boost::uint32_t>(45995730u),
                         static_cast<boost::uint32_t>(13339535u),
                         static_cast<boost::uint32_t>(2637558u),
                         static_cast<boost::uint32_t>(357423u),
                         static_cast<boost::uint32_t>(32670u),
                         static_cast<boost::uint32_t>(1925u),
                         static_cast<boost::uint32_t>(66u),
                         static_cast<boost::uint32_t>(1u)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                
                   template<class T>
                   static T lanczos_sum_near_1(const T& dz)
                   {
                      static const T d[12] = {
                         static_cast<T>(2.208709979316623790862569924861841433016L),
                         static_cast<T>(-3.327150580651624233553677113928873034916L),
                         static_cast<T>(1.483082862367253753040442933770164111678L),
                         static_cast<T>(-0.1993758927614728757314233026257810172008L),
                         static_cast<T>(0.004785200610085071473880915854204301886437L),
                         static_cast<T>(-0.1515973019871092388943437623825208095123e-5L),
                         static_cast<T>(-0.2752907702903126466004207345038327818713e-7L),
                         static_cast<T>(0.3075580174791348492737947340039992829546e-7L),
                         static_cast<T>(-0.1933117898880828348692541394841204288047e-7L),
                         static_cast<T>(0.8690926181038057039526127422002498960172e-8L),
                         static_cast<T>(-0.2499505151487868335680273909354071938387e-8L),
                         static_cast<T>(0.3394643171893132535170101292240837927725e-9L),
                      };
                      T result = 0;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(k*dz + k*k);
                      }
                      return result;
                   }
                
                   template<class T>
                   static T lanczos_sum_near_2(const T& dz)
                   {
                      static const T d[12] = {
                         static_cast<T>(6.565936202082889535528455955485877361223L),
                         static_cast<T>(-9.8907772644920670589288081640128194231L),
                         static_cast<T>(4.408830289125943377923077727900630927902L),
                         static_cast<T>(-0.5926941084905061794445733628891024027949L),
                         static_cast<T>(0.01422519127192419234315002746252160965831L),
                         static_cast<T>(-0.4506604409707170077136555010018549819192e-5L),
                         static_cast<T>(-0.8183698410724358930823737982119474130069e-7L),
                         static_cast<T>(0.9142922068165324132060550591210267992072e-7L),
                         static_cast<T>(-0.5746670642147041587497159649318454348117e-7L),
                         static_cast<T>(0.2583592566524439230844378948704262291927e-7L),
                         static_cast<T>(-0.7430396708998719707642735577238449585822e-8L),
                         static_cast<T>(0.1009141566987569892221439918230042368112e-8L),
                      };
                      T result = 0;
                      T z = dz + 2;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(z + k*z + k*k - 1);
                      }
                      return result;
                   }
                
                   static double g(){ return 6.024680040776729583740234375; }
                };
                
                //
                // Lanczos Coefficients for N=17 G=12.2252227365970611572265625
                // Max experimental error (with arbitary precision arithmetic) 2.7699e-26
                // Generated with compiler: Microsoft Visual C++ version 8.0 on Win32 at Mar 23 2006
                //
                struct lanczos17m64 : public mpl::int_<64>
                {
                   //
                   // Use for extended-double precision, when evaluated as an extended-double:
                   //
                   template <class T>
           1 ->    static T lanczos_sum(const T& z)
                   {
                      lanczos_initializer<lanczos17m64, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[17] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 553681095419291969.2230556393350368550504)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 731918863887667017.2511276782146694632234)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 453393234285807339.4627124634539085143364)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 174701893724452790.3546219631779712198035)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 46866125995234723.82897281620357050883077)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 9281280675933215.169109622777099699054272)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 1403600894156674.551057997617468721789536)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 165345984157572.7305349809894046783973837)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 15333629842677.31531822808737907246817024)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 1123152927963.956626161137169462874517318)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 64763127437.92329018717775593533620578237)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 2908830362.657527782848828237106640944457)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 99764700.56999856729959383751710026787811)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 2525791.604886139959837791244686290089331)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 44516.94034970167828580039370201346554872)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 488.0063567520005730476791712814838113252)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 2.50662827463100050241576877135758834683))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint64_t) denom[17] = {
                         BOOST_MATH_INT_VALUE_SUFFIX(0, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1307674368000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(4339163001600, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(6165817614720, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(5056995703824, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(2706813345600, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1009672107080, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(272803210680, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(54631129553, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(8207628000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(928095740, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(78558480, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(4899622, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(218400, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(6580, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(120, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1, uLL)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                   template <class T>
           1 ->    static T lanczos_sum_expG_scaled(const T& z)
                   {
                      lanczos_initializer<lanczos17m64, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[17] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 2715894658327.717377557655133124376674911)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 3590179526097.912105038525528721129550434)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 2223966599737.814969312127353235818710172)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 856940834518.9562481809925866825485883417)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 229885871668.749072933597446453399395469)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 45526171687.54610815813502794395753410032)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 6884887713.165178784550917647709216424823)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 811048596.1407531864760282453852372777439)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 75213915.96540822314499613623119501704812)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 5509245.417224265151697527957954952830126)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 317673.5368435419126714931842182369574221)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 14268.27989845035520147014373320337523596)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 489.3618720403263670213909083601787814792)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 12.38941330038454449295883217865458609584)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.2183627389504614963941574507281683147897)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.002393749522058449186690627996063983095463)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.1229541408909435212800785616808830746135e-4))
                      };
                      static const BOOST_MATH_INT_TABLE_TYPE(T, boost::uint64_t) denom[17] = {
                         BOOST_MATH_INT_VALUE_SUFFIX(0, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1307674368000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(4339163001600, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(6165817614720, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(5056995703824, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(2706813345600, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1009672107080, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(272803210680, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(54631129553, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(8207628000, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(928095740, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(78558480, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(4899622, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(218400, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(6580, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(120, uLL),
                         BOOST_MATH_INT_VALUE_SUFFIX(1, uLL)
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                
                   template<class T>
           1 ->    static T lanczos_sum_near_1(const T& dz)
                   {
                      lanczos_initializer<lanczos17m64, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[16] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 4.493645054286536365763334986866616581265)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -16.95716370392468543800733966378143997694)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 26.19196892983737527836811770970479846644)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -21.3659076437988814488356323758179283908)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 9.913992596774556590710751047594507535764)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -2.62888300018780199210536267080940382158)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.3807056693542503606384861890663080735588)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.02714647489697685807340312061034730486958)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.0007815484715461206757220527133967191796747)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.6108630817371501052576880554048972272435e-5)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.5037380238864836824167713635482801545086e-8)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.1483232144262638814568926925964858237006e-13)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.1346609158752142460943888149156716841693e-14)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.660492688923978805315914918995410340796e-15)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.1472114697343266749193617793755763792681e-15)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.1410901942033374651613542904678399264447e-16)),
                      };
                      T result = 0;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(k*dz + k*k);
                      }
                      return result;
                   }
                
                   template<class T>
           1 ->    static T lanczos_sum_near_2(const T& dz)
                   {
                      lanczos_initializer<lanczos17m64, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[16] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 23.56409085052261327114594781581930373708)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -88.92116338946308797946237246006238652361)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 137.3472822086847596961177383569603988797)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -112.0400438263562152489272966461114852861)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 51.98768915202973863076166956576777843805)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -13.78552090862799358221343319574970124948)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 1.996371068830872830250406773917646121742)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.1423525874909934506274738563671862576161)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.004098338646046865122459664947239111298524)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.3203286637326511000882086573060433529094e-4)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.2641536751640138646146395939004587594407e-7)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.7777876663062235617693516558976641009819e-13)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.7061443477097101636871806229515157914789e-14)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.3463537849537988455590834887691613484813e-14)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, 0.7719578215795234036320348283011129450595e-15)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 64, -0.7398586479708476329563577384044188912075e-16)),
                      };
                      T result = 0;
                      T z = dz + 2;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(z + k*z + k*k - 1);
                      }
                      return result;
                   }
                
           1 ->    static double g(){ return 12.2252227365970611572265625; }
                };
                
                //
                // Lanczos Coefficients for N=24 G=20.3209821879863739013671875
                // Max experimental error (with arbitary precision arithmetic) 1.0541e-38
                // Generated with compiler: Microsoft Visual C++ version 8.0 on Win32 at Mar 23 2006
                //
                struct lanczos24m113 : public mpl::int_<113>
                {
                   //
                   // Use for long-double precision, when evaluated as an long-double:
                   //
                   template <class T>
                   static T lanczos_sum(const T& z)
                   {
                      lanczos_initializer<lanczos24m113, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[24] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 2029889364934367661624137213253.22102954656825019111612712252027267955023987678816620961507)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 2338599599286656537526273232565.2727349714338768161421882478417543004440597874814359063158)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1288527989493833400335117708406.3953711906175960449186720680201425446299360322830739180195)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 451779745834728745064649902914.550539158066332484594436145043388809847364393288132164411521)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 113141284461097964029239556815.291212318665536114012605167994061291631013303788706545334708)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 21533689802794625866812941616.7509064680880468667055339259146063256555368135236149614592432)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 3235510315314840089932120340.71494940111731241353655381919722177496659303550321056514776757)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 393537392344185475704891959.081297108513472083749083165179784098220158201055270548272414314)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 39418265082950435024868801.5005452240816902251477336582325944930252142622315101857742955673)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 3290158764187118871697791.05850632319194734270969161036889516414516566453884272345518372696)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 230677110449632078321772.618245845856640677845629174549731890660612368500786684333975350954)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 13652233645509183190158.5916189185218250859402806777406323001463296297553612462737044693697)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 683661466754325350495.216655026531202476397782296585200982429378069417193575896602446904762)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 28967871782219334117.0122379171041074970463982134039409352925258212207710168851968215545064)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1036104088560167006.2022834098572346459442601718514554488352117620272232373622553429728555)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 31128490785613152.8380102669349814751268126141105475287632676569913936040772990253369753962)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 779327504127342.536207878988196814811198475410572992436243686674896894543126229424358472541)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 16067543181294.643350688789124777020407337133926174150582333950666044399234540521336771876)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 268161795520.300916569439413185778557212729611517883948634711190170998896514639936969855484)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 3533216359.10528191668842486732408440112703691790824611391987708562111396961696753452085068)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 35378979.5479656110614685178752543826919239614088343789329169535932709470588426584501652577)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 253034.881362204346444503097491737872930637147096453940375713745904094735506180552724766444)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1151.61895453463992438325318456328526085882924197763140514450975619271382783957699017875304)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 2.50662827463100050241576528481104515966515623051532908941425544355490413900497467936202516))
                      };
                      static const T denom[24] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.112400072777760768e22)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.414847677933545472e22)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 6756146673770930688000.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 6548684852703068697600.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 4280722865357147142912.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 2021687376910682741568.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 720308216440924653696.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 199321978221066137360.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 43714229649594412832.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 7707401101297361068.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1103230881185949736.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 129006659818331295.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 12363045847086207.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 971250460939913.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 62382416421941.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 3256091103430.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 136717357942.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 4546047198.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 116896626)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 2240315)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 30107)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 253)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1))
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                   template <class T>
                   static T lanczos_sum_expG_scaled(const T& z)
                   {
                      lanczos_initializer<lanczos24m113, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T num[24] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 3035162425359883494754.02878223286972654682199012688209026810841953293372712802258398358538)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 3496756894406430103600.16057175075063458536101374170860226963245118484234495645518505519827)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1926652656689320888654.01954015145958293168365236755537645929361841917596501251362171653478)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 675517066488272766316.083023742440619929434602223726894748181327187670231286180156444871912)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 169172853104918752780.086262749564831660238912144573032141700464995906149421555926000038492)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 32197935167225605785.6444116302160245528783954573163541751756353183343357329404208062043808)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 4837849542714083249.37587447454818124327561966323276633775195138872820542242539845253171632)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 588431038090493242.308438203986649553459461798968819276505178004064031201740043314534404158)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 58939585141634058.6206417889192563007809470547755357240808035714047014324843817783741669733)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 4919561837722192.82991866530802080996138070630296720420704876654726991998309206256077395868)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 344916580244240.407442753122831512004021081677987651622305356145640394384006997569631719101)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 20413302960687.8250598845969238472629322716685686993835561234733641729957841485003560103066)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1022234822943.78400752460970689311934727763870970686747383486600540378889311406851534545789)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 43313787191.9821354846952908076307094286897439975815501673706144217246093900159173598852503)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1549219505.59667418528481770869280437577581951167003505825834192510436144666564648361001914)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 46544421.1998761919380541579358096705925369145324466147390364674998568485110045455014967149)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1165278.06807504975090675074910052763026564833951579556132777702952882101173607903881127542)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 24024.759267256769471083727721827405338569868270177779485912486668586611981795179894572115)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 400.965008113421955824358063769761286758463521789765880962939528760888853281920872064838918)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 5.28299015654478269617039029170846385138134929147421558771949982217659507918482272439717603)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.0528999024412510102409256676599360516359062802002483877724963720047531347449011629466149805)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.000378346710654740685454266569593414561162134092347356968516522170279688139165340746957511115)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.172194142179211139195966608011235161516824700287310869949928393345257114743230967204370963e-5)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.374799931707148855771381263542708435935402853962736029347951399323367765509988401336565436e-8))
                      };
                      static const T denom[24] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.112400072777760768e22)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.414847677933545472e22)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 6756146673770930688000.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 6548684852703068697600.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 4280722865357147142912.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 2021687376910682741568.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 720308216440924653696.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 199321978221066137360.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 43714229649594412832.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 7707401101297361068.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1103230881185949736.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 129006659818331295.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 12363045847086207.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 971250460939913.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 62382416421941.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 3256091103430.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 136717357942.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 4546047198.0)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 116896626)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 2240315)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 30107)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 253)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1))
                      };
                      return boost::math::tools::evaluate_rational(num, denom, z);
                   }
                
                
                   template<class T>
                   static T lanczos_sum_near_1(const T& dz)
                   {
                      lanczos_initializer<lanczos24m113, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[23] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 7.4734083002469026177867421609938203388868806387315406134072298925733950040583068760685908)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -50.4225805042247530267317342133388132970816607563062253708655085754357843064134941138154171)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 152.288200621747008570784082624444625293884063492396162110698238568311211546361189979357019)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -271.894959539150384169327513139846971255640842175739337449692360299099322742181325023644769)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 319.240102980202312307047586791116902719088581839891008532114107693294261542869734803906793)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -259.493144143048088289689500935518073716201741349569864988870534417890269467336454358361499)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 149.747518319689708813209645403067832020714660918583227716408482877303972685262557460145835)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -61.9261301009341333289187201425188698128684426428003249782448828881580630606817104372760037)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 18.3077524177286961563937379403377462608113523887554047531153187277072451294845795496072365)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -3.82011322251948043097070160584761236869363471824695092089556195047949392738162970152230254)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.549382685505691522516705902336780999493262538301283190963770663549981309645795228539620711)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.0524814679715180697633723771076668718265358076235229045603747927518423453658004287459638024)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.00315392664003333528534120626687784812050217700942910879712808180705014754163256855643360698)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.000110098373127648510519799564665442121339511198561008748083409549601095293123407080388658329)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.19809382866681658224945717689377373458866950897791116315219376038432014207446832310901893e-5)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.152278977408600291408265615203504153130482270424202400677280558181047344681214058227949755e-7)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.364344768076106268872239259083188037615571711218395765792787047015406264051536972018235217e-10)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.148897510480440424971521542520683536298361220674662555578951242811522959610991621951203526e-13)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.261199241161582662426512749820666625442516059622425213340053324061794752786482115387573582e-18)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.780072664167099103420998436901014795601783313858454665485256897090476089641613851903791529e-24)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.303465867587106629530056603454807425512962762653755513440561256044986695349304176849392735e-24)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.615420597971283870342083342286977366161772327800327789325710571275345878439656918541092056e-25)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.499641233843540749369110053005439398774706583601830828776209650445427083113181961630763702e-26)),
                      };
                      T result = 0;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(k*dz + k*k);
                      }
                      return result;
                   }
                
                   template<class T>
                   static T lanczos_sum_near_2(const T& dz)
                   {
                      lanczos_initializer<lanczos24m113, T>::force_instantiate(); // Ensure our constants get initialized before main()
                      static const T d[23] = {
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 61.4165001061101455341808888883960361969557848005400286332291451422461117307237198559485365)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -414.372973678657049667308134761613915623353625332248315105320470271523320700386200587519147)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1251.50505818554680171298972755376376836161706773644771875668053742215217922228357204561873)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -2234.43389421602399514176336175766511311493214354568097811220122848998413358085613880612158)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 2623.51647746991904821899989145639147785427273427135380151752779100215839537090464785708684)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -2132.51572435428751962745870184529534443305617818870214348386131243463614597272260797772423)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 1230.62572059218405766499842067263311220019173335523810725664442147670956427061920234820189)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -508.90919151163744999377586956023909888833335885805154492270846381061182696305011395981929)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 150.453184562246579758706538566480316921938628645961177699894388251635886834047343195475395)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -31.3937061525822497422230490071156186113405446381476081565548185848237169870395131828731397)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 4.51482916590287954234936829724231512565732528859217337795452389161322923867318809206313688)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.431292919341108177524462194102701868233551186625103849565527515201492276412231365776131952)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.0259189820815586225636729971503340447445001375909094681698918294680345547092233915092128323)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.000904788882557558697594884691337532557729219389814315972435534723829065673966567231504429712)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.162793589759218213439218473348810982422449144393340433592232065020562974405674317564164312e-4)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.125142926178202562426432039899709511761368233479483128438847484617555752948755923647214487e-6)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.299418680048132583204152682950097239197934281178261879500770485862852229898797687301941982e-9)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.122364035267809278675627784883078206654408225276233049012165202996967011873995261617995421e-12)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.21465364366598631597052073538883430194257709353929022544344097235100199405814005393447785e-17)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.641064035802907518396608051803921688237330857546406669209280666066685733941549058513986818e-23)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.249388374622173329690271566855185869111237201309011956145463506483151054813346819490278951e-23)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, -0.505752900177513489906064295001851463338022055787536494321532352380960774349054239257683149e-24)),
                         static_cast<T>(BOOST_MATH_BIG_CONSTANT(T, 113, 0.410605371184590959139968810080063542546949719163227555918846829816144878123034347778284006e-25)),
                      };
                      T result = 0;
                      T z = dz + 2;
                      for(unsigned k = 1; k <= sizeof(d)/sizeof(d[0]); ++k)
                      {
                         result += (-d[k-1]*dz)/(z + k*z + k*k - 1);
                      }
                      return result;
                   }
                
                   static double g(){ return 20.3209821879863739013671875; }
                };
                
                
                //
                // placeholder for no lanczos info available:
                //
                struct undefined_lanczos : public mpl::int_<INT_MAX - 1> { };
                
                #if 0
                #ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
                #define BOOST_MATH_FLT_DIGITS ::std::numeric_limits<float>::digits
                #define BOOST_MATH_DBL_DIGITS ::std::numeric_limits<double>::digits
                #define BOOST_MATH_LDBL_DIGITS ::std::numeric_limits<long double>::digits
                #else
                #define BOOST_MATH_FLT_DIGITS FLT_MANT_DIG
                #define BOOST_MATH_DBL_DIGITS DBL_MANT_DIG
                #define BOOST_MATH_LDBL_DIGITS LDBL_MANT_DIG
                #endif
                #endif
                
                typedef mpl::list<
                   lanczos6m24, 
                /*   lanczos6, */
                   lanczos13m53, 
                /*   lanczos13, */
                   lanczos17m64, 
                   lanczos24m113, 
                   lanczos22, 
                   undefined_lanczos> lanczos_list;
                
                template <class Real, class Policy>
                struct lanczos
                {
                   typedef typename mpl::if_<
                      typename mpl::less_equal<
                         typename policies::precision<Real, Policy>::type,
                         mpl::int_<0>
                      >::type,
                      mpl::int_<INT_MAX - 2>,
                      typename policies::precision<Real, Policy>::type
                   >::type target_precision;
                
                   typedef typename mpl::deref<typename mpl::find_if<
                      lanczos_list, 
                      mpl::less_equal<target_precision, mpl::_1> >::type>::type type;
                };
                
                } // namespace lanczos
                } // namespace math
                } // namespace boost
                
                #if !defined(_CRAYC) && !defined(__CUDACC__) && (!defined(__GNUC__) || (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ > 3)))
                #if (defined(_M_IX86_FP) && (_M_IX86_FP >= 2)) || defined(__SSE2__)
                #include <boost/math/special_functions/detail/lanczos_sse2.hpp>
                #endif
                #endif
                
                #endif // BOOST_MATH_SPECIAL_FUNCTIONS_LANCZOS
                
                
                
                


Top 10 Lines:

     Line      Count

       55          4
       58          4
       46          1
      876          1
      921          1
      967          1
      997          1
     1027          1

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

       14   Total number of line executions
     1.75   Average executions per line


*** File /usr/include/boost/random/mersenne_twister.hpp:
                /* boost random/mersenne_twister.hpp header file
                 *
                 * Copyright Jens Maurer 2000-2001
                 * Copyright Steven Watanabe 2010
                 * Distributed under the Boost Software License, Version 1.0. (See
                 * accompanying file LICENSE_1_0.txt or copy at
                 * http://www.boost.org/LICENSE_1_0.txt)
                 *
                 * See http://www.boost.org for most recent version including documentation.
                 *
                 * $Id: mersenne_twister.hpp 74867 2011-10-09 23:13:31Z steven_watanabe $
                 *
                 * Revision history
                 *  2001-02-18  moved to individual header files
                 */
                
                #ifndef BOOST_RANDOM_MERSENNE_TWISTER_HPP
                #define BOOST_RANDOM_MERSENNE_TWISTER_HPP
                
                #include <iosfwd>
                #include <istream>
                #include <stdexcept>
                #include <boost/config.hpp>
                #include <boost/cstdint.hpp>
                #include <boost/integer/integer_mask.hpp>
                #include <boost/random/detail/config.hpp>
                #include <boost/random/detail/ptr_helper.hpp>
                #include <boost/random/detail/seed.hpp>
                #include <boost/random/detail/seed_impl.hpp>
                #include <boost/random/detail/generator_seed_seq.hpp>
                
                namespace boost {
                namespace random {
                
                /**
                 * Instantiations of class template mersenne_twister_engine model a
                 * \pseudo_random_number_generator. It uses the algorithm described in
                 *
                 *  @blockquote
                 *  "Mersenne Twister: A 623-dimensionally equidistributed uniform
                 *  pseudo-random number generator", Makoto Matsumoto and Takuji Nishimura,
                 *  ACM Transactions on Modeling and Computer Simulation: Special Issue on
                 *  Uniform Random Number Generation, Vol. 8, No. 1, January 1998, pp. 3-30. 
                 *  @endblockquote
                 *
                 * @xmlnote
                 * The boost variant has been implemented from scratch and does not
                 * derive from or use mt19937.c provided on the above WWW site. However, it
                 * was verified that both produce identical output.
                 * @endxmlnote
                 *
                 * The seeding from an integer was changed in April 2005 to address a
                 * <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html">weakness</a>.
                 * 
                 * The quality of the generator crucially depends on the choice of the
                 * parameters.  User code should employ one of the sensibly parameterized
                 * generators such as \mt19937 instead.
                 *
                 * The generator requires considerable amounts of memory for the storage of
                 * its state array. For example, \mt11213b requires about 1408 bytes and
                 * \mt19937 requires about 2496 bytes.
                 */
                template<class UIntType,
                         std::size_t w, std::size_t n, std::size_t m, std::size_t r,
                         UIntType a, std::size_t u, UIntType d, std::size_t s,
                         UIntType b, std::size_t t,
                         UIntType c, std::size_t l, UIntType f>
                class mersenne_twister_engine
                {
                public:
                    typedef UIntType result_type;
                    BOOST_STATIC_CONSTANT(std::size_t, word_size = w);
                    BOOST_STATIC_CONSTANT(std::size_t, state_size = n);
                    BOOST_STATIC_CONSTANT(std::size_t, shift_size = m);
                    BOOST_STATIC_CONSTANT(std::size_t, mask_bits = r);
                    BOOST_STATIC_CONSTANT(UIntType, xor_mask = a);
                    BOOST_STATIC_CONSTANT(std::size_t, tempering_u = u);
                    BOOST_STATIC_CONSTANT(UIntType, tempering_d = d);
                    BOOST_STATIC_CONSTANT(std::size_t, tempering_s = s);
                    BOOST_STATIC_CONSTANT(UIntType, tempering_b = b);
                    BOOST_STATIC_CONSTANT(std::size_t, tempering_t = t);
                    BOOST_STATIC_CONSTANT(UIntType, tempering_c = c);
                    BOOST_STATIC_CONSTANT(std::size_t, tempering_l = l);
                    BOOST_STATIC_CONSTANT(UIntType, initialization_multiplier = f);
                    BOOST_STATIC_CONSTANT(UIntType, default_seed = 5489u);
                  
                    // backwards compatibility
                    BOOST_STATIC_CONSTANT(UIntType, parameter_a = a);
                    BOOST_STATIC_CONSTANT(std::size_t, output_u = u);
                    BOOST_STATIC_CONSTANT(std::size_t, output_s = s);
                    BOOST_STATIC_CONSTANT(UIntType, output_b = b);
                    BOOST_STATIC_CONSTANT(std::size_t, output_t = t);
                    BOOST_STATIC_CONSTANT(UIntType, output_c = c);
                    BOOST_STATIC_CONSTANT(std::size_t, output_l = l);
                    
                    // old Boost.Random concept requirements
                    BOOST_STATIC_CONSTANT(bool, has_fixed_range = false);
                
                
                    /**
                     * Constructs a @c mersenne_twister_engine and calls @c seed().
                     */
                    mersenne_twister_engine() { seed(); }
                
                    /**
                     * Constructs a @c mersenne_twister_engine and calls @c seed(value).
                     */
          12 ->     BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR(mersenne_twister_engine,
                                                               UIntType, value)
                    { seed(value); }
                    template<class It> mersenne_twister_engine(It& first, It last)
                    { seed(first,last); }
                
                    /**
                     * Constructs a mersenne_twister_engine and calls @c seed(gen).
                     *
                     * @xmlnote
                     * The copy constructor will always be preferred over
                     * the templated constructor.
                     * @endxmlnote
                     */
                    BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR(mersenne_twister_engine,
                                                             SeedSeq, seq)
                    { seed(seq); }
                
                    // compiler-generated copy ctor and assignment operator are fine
                
                    /** Calls @c seed(default_seed). */
                    void seed() { seed(default_seed); }
                
                    /**
                     * Sets the state x(0) to v mod 2w. Then, iteratively,
                     * sets x(i) to
                     * (i + f * (x(i-1) xor (x(i-1) rshift w-2))) mod 2<sup>w</sup>
                     * for i = 1 .. n-1. x(n) is the first value to be returned by operator().
                     */
          12 ->     BOOST_RANDOM_DETAIL_ARITHMETIC_SEED(mersenne_twister_engine, UIntType, value)
                    {
                        // New seeding algorithm from 
                        // http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
                        // In the previous versions, MSBs of the seed affected only MSBs of the
                        // state x[].
                        const UIntType mask = (max)();
                        x[0] = value & mask;
                        for (i = 1; i < n; i++) {
                            // See Knuth "The Art of Computer Programming"
                            // Vol. 2, 3rd ed., page 106
                            x[i] = (f * (x[i-1] ^ (x[i-1] >> (w-2))) + i) & mask;
                        }
                    }
                    
                    /**
                     * Seeds a mersenne_twister_engine using values produced by seq.generate().
                     */
                    BOOST_RANDOM_DETAIL_SEED_SEQ_SEED(mersenne_twister_engine, SeeqSeq, seq)
                    {
                        detail::seed_array_int<w>(seq, x);
                        i = n;
                
                        // fix up the state if it's all zeroes.
                        if((x[0] & (~static_cast<UIntType>(0) << r)) == 0) {
                            for(std::size_t j = 1; j < n; ++j) {
                                if(x[j] != 0) return;
                            }
                            x[0] = static_cast<UIntType>(1) << (w-1);
                        }
                    }
                
                    /** Sets the state of the generator using values from an iterator range. */
                    template<class It>
                    void seed(It& first, It last)
                    {
                        detail::fill_array_int<w>(first, last, x);
                        i = n;
                
                        // fix up the state if it's all zeroes.
                        if((x[0] & (~static_cast<UIntType>(0) << r)) == 0) {
                            for(std::size_t j = 1; j < n; ++j) {
                                if(x[j] != 0) return;
                            }
                            x[0] = static_cast<UIntType>(1) << (w-1);
                        }
                    }
                  
                    /** Returns the smallest value that the generator can produce. */
       48000 ->     static result_type min BOOST_PREVENT_MACRO_SUBSTITUTION ()
                    { return 0; }
                    /** Returns the largest value that the generator can produce. */
       24012 ->     static result_type max BOOST_PREVENT_MACRO_SUBSTITUTION ()
                    { return boost::low_bits_mask_t<w>::sig_bits; }
                    
                    /** Produces the next value of the generator. */
                    result_type operator()();
                
                    /** Fills a range with random values */
                    template<class Iter>
                    void generate(Iter first, Iter last)
                    { detail::generate_from_int(*this, first, last); }
                
                    /**
                     * Advances the state of the generator by @c z steps.  Equivalent to
                     *
                     * @code
                     * for(unsigned long long i = 0; i < z; ++i) {
                     *     gen();
                     * }
                     * @endcode
                     */
                    void discard(boost::uintmax_t z)
                    {
                        for(boost::uintmax_t j = 0; j < z; ++j) {
                            (*this)();
                        }
                    }
                
                #ifndef BOOST_RANDOM_NO_STREAM_OPERATORS
                    /** Writes a mersenne_twister_engine to a @c std::ostream */
                    template<class CharT, class Traits>
                    friend std::basic_ostream<CharT,Traits>&
                    operator<<(std::basic_ostream<CharT,Traits>& os,
                               const mersenne_twister_engine& mt)
                    {
                        mt.print(os);
                        return os;
                    }
                    
                    /** Reads a mersenne_twister_engine from a @c std::istream */
                    template<class CharT, class Traits>
                    friend std::basic_istream<CharT,Traits>&
                    operator>>(std::basic_istream<CharT,Traits>& is,
                               mersenne_twister_engine& mt)
                    {
                        for(std::size_t j = 0; j < mt.state_size; ++j)
                            is >> mt.x[j] >> std::ws;
                        // MSVC (up to 7.1) and Borland (up to 5.64) don't handle the template
                        // value parameter "n" available from the class template scope, so use
                        // the static constant with the same value
                        mt.i = mt.state_size;
                        return is;
                    }
                #endif
                
                    /**
                     * Returns true if the two generators are in the same state,
                     * and will thus produce identical sequences.
                     */
                    friend bool operator==(const mersenne_twister_engine& x,
                                           const mersenne_twister_engine& y)
                    {
                        if(x.i < y.i) return x.equal_imp(y);
                        else return y.equal_imp(x);
                    }
                    
                    /**
                     * Returns true if the two generators are in different states.
                     */
                    friend bool operator!=(const mersenne_twister_engine& x,
                                           const mersenne_twister_engine& y)
                    { return !(x == y); }
                
                private:
                    /// \cond show_private
                
                    void twist();
                
                    /**
                     * Does the work of operator==.  This is in a member function
                     * for portability.  Some compilers, such as msvc 7.1 and
                     * Sun CC 5.10 can't access template parameters or static
                     * members of the class from inline friend functions.
                     *
                     * requires i <= other.i
                     */
                    bool equal_imp(const mersenne_twister_engine& other) const
                    {
                        UIntType back[n];
                        std::size_t offset = other.i - i;
                        for(std::size_t j = 0; j + offset < n; ++j)
                            if(x[j] != other.x[j+offset])
                                return false;
                        rewind(&back[n-1], offset);
                        for(std::size_t j = 0; j < offset; ++j)
                            if(back[j + n - offset] != other.x[j])
                                return false;
                        return true;
                    }
                
                    /**
                     * Does the work of operator<<.  This is in a member function
                     * for portability.
                     */
                    template<class CharT, class Traits>
                    void print(std::basic_ostream<CharT, Traits>& os) const
                    {
                        UIntType data[n];
                        for(std::size_t j = 0; j < i; ++j) {
                            data[j + n - i] = x[j];
                        }
                        if(i != n) {
                            rewind(&data[n - i - 1], n - i);
                        }
                        os << data[0];
                        for(std::size_t j = 1; j < n; ++j) {
                            os << ' ' << data[j];
                        }
                    }
                
                    /**
                     * Copies z elements of the state preceding x[0] into
                     * the array whose last element is last.
                     */
                    void rewind(UIntType* last, std::size_t z) const
                    {
                        const UIntType upper_mask = (~static_cast<UIntType>(0)) << r;
                        const UIntType lower_mask = ~upper_mask;
                        UIntType y0 = x[m-1] ^ x[n-1];
                        if(y0 & (static_cast<UIntType>(1) << (w-1))) {
                            y0 = ((y0 ^ a) << 1) | 1;
                        } else {
                            y0 = y0 << 1;
                        }
                        for(std::size_t sz = 0; sz < z; ++sz) {
                            UIntType y1 =
                                rewind_find(last, sz, m-1) ^ rewind_find(last, sz, n-1);
                            if(y1 & (static_cast<UIntType>(1) << (w-1))) {
                                y1 = ((y1 ^ a) << 1) | 1;
                            } else {
                                y1 = y1 << 1;
                            }
                            *(last - sz) = (y0 & upper_mask) | (y1 & lower_mask);
                            y0 = y1;
                        }
                    }
                
                    /**
                     * Given a pointer to the last element of the rewind array,
                     * and the current size of the rewind array, finds an element
                     * relative to the next available slot in the rewind array.
                     */
                    UIntType
                    rewind_find(UIntType* last, std::size_t size, std::size_t j) const
                    {
                        std::size_t index = (j + n - size + n - 1) % n;
                        if(index < n - size) {
                            return x[index];
                        } else {
                            return *(last - (n - 1 - index));
                        }
                    }
                
                    /// \endcond
                
                    // state representation: next output is o(x(i))
                    //   x[0]  ... x[k] x[k+1] ... x[n-1]   represents
                    //  x(i-k) ... x(i) x(i+1) ... x(i-k+n-1)
                
                    UIntType x[n]; 
                    std::size_t i;
                };
                
                /// \cond show_private
                
                #ifndef BOOST_NO_INCLASS_MEMBER_INITIALIZATION
                //  A definition is required even for integral static constants
                #define BOOST_RANDOM_MT_DEFINE_CONSTANT(type, name)                         \
                template<class UIntType, std::size_t w, std::size_t n, std::size_t m,       \
                    std::size_t r, UIntType a, std::size_t u, UIntType d, std::size_t s,    \
                    UIntType b, std::size_t t, UIntType c, std::size_t l, UIntType f>       \
                const type mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::name
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, word_size);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, state_size);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, shift_size);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, mask_bits);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, xor_mask);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, tempering_u);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, tempering_d);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, tempering_s);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, tempering_b);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, tempering_t);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, tempering_c);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, tempering_l);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, initialization_multiplier);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, default_seed);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, parameter_a);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, output_u );
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, output_s);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, output_b);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, output_t);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(UIntType, output_c);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(std::size_t, output_l);
                BOOST_RANDOM_MT_DEFINE_CONSTANT(bool, has_fixed_range);
                #undef BOOST_RANDOM_MT_DEFINE_CONSTANT
                #endif
                
                template<class UIntType,
                         std::size_t w, std::size_t n, std::size_t m, std::size_t r,
                         UIntType a, std::size_t u, UIntType d, std::size_t s,
                         UIntType b, std::size_t t,
                         UIntType c, std::size_t l, UIntType f>
                void
          48 -> mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::twist()
                {
                    const UIntType upper_mask = (~static_cast<UIntType>(0)) << r;
                    const UIntType lower_mask = ~upper_mask;
                
                    const std::size_t unroll_factor = 6;
                    const std::size_t unroll_extra1 = (n-m) % unroll_factor;
                    const std::size_t unroll_extra2 = (m-1) % unroll_factor;
                
                    // split loop to avoid costly modulo operations
                    {  // extra scope for MSVC brokenness w.r.t. for scope
                        for(std::size_t j = 0; j < n-m-unroll_extra1; j++) {
                            UIntType y = (x[j] & upper_mask) | (x[j+1] & lower_mask);
                            x[j] = x[j+m] ^ (y >> 1) ^ ((x[j+1]&1) * a);
                        }
                    }
                    {
                        for(std::size_t j = n-m-unroll_extra1; j < n-m; j++) {
                            UIntType y = (x[j] & upper_mask) | (x[j+1] & lower_mask);
                            x[j] = x[j+m] ^ (y >> 1) ^ ((x[j+1]&1) * a);
                        }
                    }
                    {
                        for(std::size_t j = n-m; j < n-1-unroll_extra2; j++) {
                            UIntType y = (x[j] & upper_mask) | (x[j+1] & lower_mask);
                            x[j] = x[j-(n-m)] ^ (y >> 1) ^ ((x[j+1]&1) * a);
                        }
                    }
                    {
                        for(std::size_t j = n-1-unroll_extra2; j < n-1; j++) {
                            UIntType y = (x[j] & upper_mask) | (x[j+1] & lower_mask);
                            x[j] = x[j-(n-m)] ^ (y >> 1) ^ ((x[j+1]&1) * a);
                        }
                    }
                    // last iteration
                    UIntType y = (x[n-1] & upper_mask) | (x[0] & lower_mask);
                    x[n-1] = x[m-1] ^ (y >> 1) ^ ((x[0]&1) * a);
                    i = 0;
                }
                /// \endcond
                
                template<class UIntType,
                         std::size_t w, std::size_t n, std::size_t m, std::size_t r,
                         UIntType a, std::size_t u, UIntType d, std::size_t s,
                         UIntType b, std::size_t t,
                         UIntType c, std::size_t l, UIntType f>
                inline typename
                mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::result_type
       24000 -> mersenne_twister_engine<UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f>::operator()()
                {
                    if(i == n)
                        twist();
                    // Step 4
                    UIntType z = x[i];
                    ++i;
                    z ^= ((z >> u) & d);
                    z ^= ((z << s) & b);
                    z ^= ((z << t) & c);
                    z ^= (z >> l);
                    return z;
                }
                
                /**
                 * The specializations \mt11213b and \mt19937 are from
                 *
                 *  @blockquote
                 *  "Mersenne Twister: A 623-dimensionally equidistributed
                 *  uniform pseudo-random number generator", Makoto Matsumoto
                 *  and Takuji Nishimura, ACM Transactions on Modeling and
                 *  Computer Simulation: Special Issue on Uniform Random Number
                 *  Generation, Vol. 8, No. 1, January 1998, pp. 3-30. 
                 *  @endblockquote
                 */
                typedef mersenne_twister_engine<uint32_t,32,351,175,19,0xccab8ee7,
                    11,0xffffffff,7,0x31b6ab00,15,0xffe50000,17,1812433253> mt11213b;
                
                /**
                 * The specializations \mt11213b and \mt19937 are from
                 *
                 *  @blockquote
                 *  "Mersenne Twister: A 623-dimensionally equidistributed
                 *  uniform pseudo-random number generator", Makoto Matsumoto
                 *  and Takuji Nishimura, ACM Transactions on Modeling and
                 *  Computer Simulation: Special Issue on Uniform Random Number
                 *  Generation, Vol. 8, No. 1, January 1998, pp. 3-30. 
                 *  @endblockquote
                 */
                typedef mersenne_twister_engine<uint32_t,32,624,397,31,0x9908b0df,
                    11,0xffffffff,7,0x9d2c5680,15,0xefc60000,18,1812433253> mt19937;
                
                #if !defined(BOOST_NO_INT64_T) && !defined(BOOST_NO_INTEGRAL_INT64_T)
                typedef mersenne_twister_engine<uint64_t,64,312,156,31,
                    UINT64_C(0xb5026f5aa96619e9),29,UINT64_C(0x5555555555555555),17,
                    UINT64_C(0x71d67fffeda60000),37,UINT64_C(0xfff7eee000000000),43,
                    UINT64_C(6364136223846793005)> mt19937_64;
                #endif
                
                /// \cond show_deprecated
                
                template<class UIntType,
                         int w, int n, int m, int r,
                         UIntType a, int u, std::size_t s,
                         UIntType b, int t,
                         UIntType c, int l, UIntType v>
                class mersenne_twister :
                    public mersenne_twister_engine<UIntType,
                        w, n, m, r, a, u, ~(UIntType)0, s, b, t, c, l, 1812433253>
                {
                    typedef mersenne_twister_engine<UIntType,
                        w, n, m, r, a, u, ~(UIntType)0, s, b, t, c, l, 1812433253> base_type;
                public:
                    mersenne_twister() {}
                    BOOST_RANDOM_DETAIL_GENERATOR_CONSTRUCTOR(mersenne_twister, Gen, gen)
                    { seed(gen); }
                    BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR(mersenne_twister, UIntType, val)
                    { seed(val); }
                    template<class It>
                    mersenne_twister(It& first, It last) : base_type(first, last) {}
                    void seed() { base_type::seed(); }
                    BOOST_RANDOM_DETAIL_GENERATOR_SEED(mersenne_twister, Gen, gen)
                    {
                        detail::generator_seed_seq<Gen> seq(gen);
                        base_type::seed(seq);
                    }
                    BOOST_RANDOM_DETAIL_ARITHMETIC_SEED(mersenne_twister, UIntType, val)
                    { base_type::seed(val); }
                    template<class It>
                    void seed(It& first, It last) { base_type::seed(first, last); }
                };
                
                /// \endcond
                
                } // namespace random
                
                using random::mt11213b;
                using random::mt19937;
                using random::mt19937_64;
                
                } // namespace boost
                
                BOOST_RANDOM_PTR_HELPER_SPEC(boost::mt11213b)
                BOOST_RANDOM_PTR_HELPER_SPEC(boost::mt19937)
                BOOST_RANDOM_PTR_HELPER_SPEC(boost::mt19937_64)
                
                #endif // BOOST_RANDOM_MERSENNE_TWISTER_HPP


Top 10 Lines:

     Line      Count

      186      48000
      189      24012
      449      24000
      401         48
      108         12
      137         12

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

    96084   Total number of line executions
 16014.00   Average executions per line


*** File /usr/include/c++/4.8/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001-2013 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                        rebind<_Tp>::other _Tp_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                       	pointer;
                
     1582608 ->       struct _Vector_impl 
                      : public _Tp_alloc_type
                      {
                	pointer _M_start;
                	pointer _M_finish;
                	pointer _M_end_of_storage;
                
       70577 -> 	_Vector_impl()
                	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                
                	_Vector_impl(_Tp_alloc_type const& __a)
                	: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                
                #if __cplusplus >= 201103L
                	_Vector_impl(_Tp_alloc_type&& __a)
                	: _Tp_alloc_type(std::move(__a)),
                	  _M_start(0), _M_finish(0), _M_end_of_storage(0)
                	{ }
                #endif
                
                	void _M_swap_data(_Vector_impl& __x)
                	{
                	  std::swap(_M_start, __x._M_start);
                	  std::swap(_M_finish, __x._M_finish);
                	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
                	}
                      };
                      
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
     1582608 ->       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                
                      const _Tp_alloc_type&
                      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
       70577 ->       _Vector_base()
                      : _M_impl() { }
                
                      _Vector_base(const allocator_type& __a)
                      : _M_impl(__a) { }
                
                      _Vector_base(size_t __n)
                      : _M_impl()
                      { _M_create_storage(__n); }
                
                      _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_create_storage(__n); }
                
                #if __cplusplus >= 201103L
                      _Vector_base(_Tp_alloc_type&& __a)
                      : _M_impl(std::move(__a)) { }
                
                      _Vector_base(_Vector_base&& __x)
                      : _M_impl(std::move(__x._M_get_Tp_allocator()))
                      { this->_M_impl._M_swap_data(__x._M_impl); }
                
                      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                	else
                	  {
                	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                	    _M_create_storage(__n);
                	  }
                      }
                #endif
                
     1582608 ->       ~_Vector_base()
                      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
                		      - this->_M_impl._M_start); }
                
                    public:
                      _Vector_impl _M_impl;
                
                      pointer
                      _M_allocate(size_t __n)
                      { return __n != 0 ? _M_impl.allocate(__n) : 0; }
                
                      void
     1582608 ->       _M_deallocate(pointer __p, size_t __n)
                      {
                	if (__p)
                	  _M_impl.deallocate(__p, __n);
                      }
                
                    private:
                      void
                      _M_create_storage(size_t __n)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                    };
                
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                      // Concept requirements.
                      typedef typename _Alloc::value_type                _Alloc_value_type;
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                      
                      typedef _Vector_base<_Tp, _Alloc>			 _Base;
                      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;
                
                    public:
                      typedef _Tp					 value_type;
                      typedef typename _Base::pointer                    pointer;
                      typedef typename _Alloc_traits::const_pointer      const_pointer;
                      typedef typename _Alloc_traits::reference          reference;
                      typedef typename _Alloc_traits::const_reference    const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		 reverse_iterator;
                      typedef size_t					 size_type;
                      typedef ptrdiff_t					 difference_type;
                      typedef _Alloc                        		 allocator_type;
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                      /**
                       *  @brief  Default constructor creates no elements.
                       */
           2 ->       vector()
                      : _Base() { }
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
                      vector(const allocator_type& __a)
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %vector with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n default
                       *  constructed elements.
                       */
                      explicit
                      vector(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_default_initialize(__n); }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      vector(size_type __n, const value_type& __value,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                #else
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(__n, __a)
                      { _M_fill_initialize(__n, __value); }
                #endif
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector uses a copy of the allocation
                       *  object used by @a __x.  All the elements of @a __x are copied,
                       *  but any extra memory in
                       *  @a __x (for fast expansion) will not be copied.
                       */
                      vector(const vector& __x)
                      : _Base(__x.size(),
                        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The newly-created %vector contains the exact contents of @a __x.
                       *  The contents of @a __x are a valid, but unspecified %vector.
                       */
                      vector(vector&& __x) noexcept
                      : _Base(std::move(__x)) { }
                
                      /// Copy constructor with alternative allocator
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__x.size(), __a)
                      { this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                      /// Move constructor with alternative allocator
                      vector(vector&& __rv, const allocator_type& __m)
                      : _Base(std::move(__rv), __m)
                      {
                	if (__rv.get_allocator() != __m)
                	  {
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                					  this->_M_impl._M_start,
                					  _M_get_Tp_allocator());
                	    __rv.clear();
                	  }
                      }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a __l.size()) and do no memory reallocation.
                       */
                      vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        { _M_initialize_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
           2 ->       ~vector() _GLIBCXX_NOEXCEPT
                      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator()); }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any extra memory in
                       *  @a __x (for fast expansion) will not be copied.  Unlike the
                       *  copy constructor, the allocator object is not copied.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this %vector (without copying,
                       *  if the allocators permit it).
                       *  @a __x is a valid, but unspecified %vector.
                       */
                      vector&
                      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                        constexpr bool __move_storage =
                          _Alloc_traits::_S_propagate_on_move_assign()
                          || _Alloc_traits::_S_always_equal();
                        _M_move_assign(std::move(__x),
                                       integral_constant<bool, __move_storage>());
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->assign(__l.begin(), __l.end());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a __n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        { _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        void
                        assign(_InputIterator __first, _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.  Old data may be lost.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      { this->assign(__l.begin(), __l.end()); }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
                      begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
                      end() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
                      resize(size_type __new_size)
                      {
                	if (__new_size > size())
                	  _M_default_append(__new_size - size());
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, const value_type& __x)
                      {
                	if (__new_size > size())
                	  insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #else
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size > size())
                	  insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  __n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
                      operator[](size_type __n)
                      { return *(this->_M_impl._M_start + __n); }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[](size_type __n) const
                      { return *(this->_M_impl._M_start + __n); }
                
                    protected:
                      /// Safety check used only from at().
                      void
                      _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range(__N("vector::_M_range_check"));
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n]; 
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front()
                      { return *begin(); }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const
                      { return *begin(); }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
                      back()
                      { return *(end() - 1); }
                      
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
                      back() const
                      { return *(end() - 1); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                #if __cplusplus >= 201103L
                      _Tp*
                #else
                      pointer
                #endif
                      data() _GLIBCXX_NOEXCEPT
                      { return std::__addressof(front()); }
                
                #if __cplusplus >= 201103L
                      const _Tp*
                #else
                      const_pointer
                #endif
                      data() const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(front()); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
                      push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                	                             __x);
                	    ++this->_M_impl._M_finish;
                	  }
                	else
                #if __cplusplus >= 201103L
                	  _M_emplace_back_aux(__x);
                #else
                	  _M_insert_aux(end(), __x);
                #endif
                      }
                
                #if __cplusplus >= 201103L
                      void
                      push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                        void
                        emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
                      pop_back()
                      {
                	--this->_M_impl._M_finish;
                	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                        iterator
                        emplace(iterator __position, _Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, value_type&& __x)
                      { return emplace(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the 
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, initializer_list<value_type> __l)
                      { this->insert(__position, __l.begin(), __l.end()); }
                #endif
                
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        { _M_insert_dispatch(__position, __first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                        void
                        insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                        {
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                      erase(iterator __position);
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                  erased.
                       *  @return  An iterator pointing to the element pointed to by @a __last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                      erase(iterator __first, iterator __last);
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  __x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       */
                      void
                      swap(vector& __x)
                #if __cplusplus >= 201103L
                			noexcept(_Alloc_traits::_S_nothrow_swap())
                #endif
                      {
                	this->_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                	                          __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                        pointer
                        _M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                        {
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                        {
                	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_initialize(__first, __last, _IterCategory());
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_initialize(_InputIterator __first,
                			    _InputIterator __last, std::input_iterator_tag)
                        {
                	  for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	    emplace_back(*__first);
                #else
                	    push_back(*__first);
                #endif
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_initialize(_ForwardIterator __first,
                			    _ForwardIterator __last, std::forward_iterator_tag)
                        {
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start = this->_M_allocate(__n);
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
                      _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, 
                				      _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                      }
                
                #if __cplusplus >= 201103L
                      // Called by the vector(n) constructor.
                      void
                      _M_default_initialize(size_type __n)
                      {
                	std::__uninitialized_default_n_a(this->_M_impl._M_start, __n, 
                					 _M_get_Tp_allocator());
                	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                      }
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                        { _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_assign_aux(__first, __last, _IterCategory());
                	}
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                        { _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                        void
                        _M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                        {
                	  typedef typename std::iterator_traits<_InputIterator>::
                	    iterator_category _IterCategory;
                	  _M_range_insert(__pos, __first, __last, _IterCategory());
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                        void
                        _M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                        void
                        _M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      // Called by resize(n).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                      // Called by insert(p,x)
                #if __cplusplus < 201103L
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                #else
                      template<typename... _Args>
                        void
                        _M_insert_aux(iterator __position, _Args&&... __args);
                
                      template<typename... _Args>
                        void
                        _M_emplace_back_aux(_Args&&... __args);
                #endif
                
                      // Called by the latter.
                      size_type
                      _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + std::max(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
                      _M_erase_at_end(pointer __pos)
                      {
                	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                	this->_M_impl._M_finish = __pos;
                      }
                
                #if __cplusplus >= 201103L
                    private:
                      // Constant-time move assignment when source object's memory can be
                      // moved, either because the source's allocator will move too
                      // or because the allocators are equal.
                      void
                      _M_move_assign(vector&& __x, std::true_type) noexcept
                      {
                	vector __tmp(get_allocator());
                	this->_M_impl._M_swap_data(__tmp._M_impl);
                	this->_M_impl._M_swap_data(__x._M_impl);
                	if (_Alloc_traits::_S_propagate_on_move_assign())
                	  std::__alloc_on_move(_M_get_Tp_allocator(),
                			       __x._M_get_Tp_allocator());
                      }
                
                      // Do move assignment when it might not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign(vector&& __x, std::false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  _M_move_assign(std::move(__x), std::true_type());
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
                			 std::__make_move_if_noexcept_iterator(__x.end()));
                	    __x.clear();
                	  }
                      }
                #endif
                    };
                
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                } // namespace std
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

       79    1582608
      113    1582608
      159    1582608
      171    1582608
       86      70577
      124      70577
      248          2
      414          2

Execution Summary:

        8   Executable lines in this file
        8   Lines executed
   100.00   Percent of the file executed

  6471590   Total number of line executions
808948.75   Average executions per line


*** File /home/niina/greens_functions/GreensFunction1DRadAbs.hpp:
                #if !defined( __GREENSFUNCTION1DRADABS_HPP )
                #define __GREENSFUNCTION1DRADABS_HPP
                
                #include <sstream>
                #include <iostream>
                #include <cstdlib>
                #include <exception>
                #include <vector>
                
                #include <gsl/gsl_math.h>
                #include <gsl/gsl_sf_trig.h>
                #include <gsl/gsl_sum.h>
                #include <gsl/gsl_errno.h>
                #include <gsl/gsl_interp.h>
                #include <gsl/gsl_sf_expint.h>
                #include <gsl/gsl_sf_elljac.h>
                #include <gsl/gsl_roots.h>
                
                #include <math.h>
                
                #include "findRoot.hpp"
                #include "funcSum.hpp" 
                #include "freeFunctions.hpp"
                #include "Defs.hpp"
                #include "GreensFunction.hpp"
                //#include "Logger.hpp"
                
                namespace greens_functions{
                
                class GreensFunction1DRadAbs: public GreensFunction
                {
                public:
                    typedef std::vector<Real> RealVector;
                    typedef unsigned int uint;
                
                private:
                    // This is a typical length scale of the system, may not be true!
                    static const Real L_TYPICAL = 1E-8;
                    // The typical timescale of the system, may also not be true!!
                    static const Real T_TYPICAL = 1E-6;
                    // measure of 'sameness' when comparing floating points numbers
                    static const Real EPSILON = 1E-10;
                    // Is 1E3 a good measure for the probability density?!
                    static const Real PDENS_TYPICAL = 1;
                    // The maximum number of terms used in calculating the sum
                    static const uint MAX_TERMS = 500;
                    // The minimum number of terms
                    static const uint MIN_TERMS = 20;
                    /* Cutoff distance: When H * sqrt(2Dt) < a - r0 OR ro - sigma
                       use free greensfunction instead of absorbing. */
                    static const Real CUTOFF_H = 6.0;
                
                public:
           1 ->     GreensFunction1DRadAbs(Real D, Real k, Real r0, Real sigma, Real a)
                	: GreensFunction(D), v(0.0), k(k), r0(r0), sigma(sigma), a(a), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
                    {
                        //set first root.
                        calculate_n_roots( 1 );
                    }
                
                    // The constructor is overloaded and can be called with or without drift v
                    // copy constructor including drift variable v
                    GreensFunction1DRadAbs(Real D, Real v, Real k, Real r0, Real sigma, Real a)
                	: GreensFunction(D), v(v), k(k), r0(r0), sigma(sigma), a(a), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
                    {
                        //set first root;
                        calculate_n_roots( 1 );
                    }
                
           1 ->     ~GreensFunction1DRadAbs()
                    {
                	;   // empty
                    }
                
                    // This also sets the scale
                    void seta(Real a)
                    {
                	THROW_UNLESS( std::invalid_argument, (a-this->sigma) >= 0.0 && this->r0 <= a);
                
                	// Use a typical domain size to determine if we are here 
                	// defining a domain of size 0.
                	if ( (a-this->sigma) < EPSILON*this->l_scale )
                	{
                	    // just some random value to show that the domain is zero
                	    this->a = -1.0;
                	}
                	else
                	{
                	    // set the l_scale to the given one
                	    this->l_scale = a-sigma;
                	    // set the typical time scale (MSD = sqrt(2*d*D*t) )
                	    this->t_scale = (l_scale*l_scale)/this->getD();
                	    this->a = a;
                	}
                    }
                
                    Real geta() const
                    {
                        return this->a;
                    }
                    
                    Real getsigma() const
                    {
                        return this->sigma;
                    }
                
                    void setr0(Real r0)
                    {
                	if ( this->a - this->sigma < 0.0 )
                	{
                	    // if the domain had zero size
                	    THROW_UNLESS( std::invalid_argument,
                	                  0.0 <= (r0-sigma) && (r0-sigma) <= EPSILON * l_scale );
                	    this->r0 = 0.0;
                	}
                	else
                	{
                	    // The normal case
                	    THROW_UNLESS( std::invalid_argument,
                	                  0.0 <= (r0-sigma) && r0 <= this->a);
                	    this->r0 = r0;
                	}
                    }
                
                    Real getr0() const
                    {
                        return r0;
                    }
                
                    Real getk() const
                    {
                        return this->k;
                    }
                
                    Real getv() const
                    {
                        return this->v;
                    }
                
                    // Calculates the probability density of finding the particle at 
                    // location z at timepoint t, given that the particle is still in the 
                    // domain.
                    Real calcpcum (Real r, Real t) const;
                
                    // Determine which event has occured, an escape or a reaction. Based 
                    // on the fluxes through the boundaries at the given time. Beware: if 
                    // t is not a first passage time you still get an answer!
                    EventKind drawEventType( Real rnd, Real t ) const;
                
                    // Draws the first passage time from the propensity function
                    Real drawTime (Real rnd) const;
                
                    // Draws the position of the particle at a given time, assuming that 
                    // the particle is still in the domain
                    Real drawR (Real rnd, Real t) const;
                
                
                // These methods are both public and private, they are used by public methods 
                // but can also be called from the 'outside'. This is mainly because of 
                // debugging purposes.
                
                
                    // Calculates the probability of finding the particle inside the 
                    // domain at time t -> the survival probability
                    Real p_survival (Real t) const;
                
                    // Calculates the total probability flux leaving the domain at time t
                    Real flux_tot (Real t) const;
                
                    // Calculates the probability flux leaving the domain through the 
                    // radiative boundary at time t
                    Real flux_rad (Real t) const;
                
                    // Calculates the flux leaving the domain through the radiative 
                    // boundary as a fraction of the total flux. This is the probability 
                    // that the particle left the domain through the radiative
                    // boundary instead of the absorbing boundary.
                    Real fluxRatioRadTot (Real t) const;
                
                    // Calculates the probability density of finding the particle at 
                    // location r at time t.
                    Real prob_r (Real r, Real t) const;
                    
                // End of public/private mix methods
                
                //private:	// method made public for testing
                
                    std::string dump() const;
                
                    const char* getName() const
                    {
                        return "GreensFunction1DRadAbs";
                    }
                    
                private:
                
                    Real An (Real a_n) const;
                
                    Real Bn (Real a_n) const;
                
                    Real Cn (Real a_n, Real t) const;
                
                    struct tan_f_params
                    {
                        Real a;
                        Real h;
                    };
                
                    struct drawT_params
                    {
                        GreensFunction1DRadAbs const* gf;
                        RealVector& psurvTable;
                        Real rnd;
                    };
                
                   struct drawR_params
                    {
                        GreensFunction1DRadAbs const* gf;
                        const Real t;
                        RealVector table;
                        Real rnd;
                    };
                
                
                    /* Functions managing the rootList */
                    
                    /* return the rootList size */
                    uint rootList_size() const
                    {
                        return rootList.size();
                    }
                
                    /* returns the last root. */
                    Real get_last_root() const
                    {
                        return rootList.back();
                    }
                
                    /* ad a root to the rootList */
                    void ad_to_rootList( Real const& root_i ) const
                    {
                        rootList.push_back( root_i );
                    }
                
                    /* remove n'th root from rootList */
                    void remove_from_rootList(uint const& n) const
                    {
                        rootList.erase( rootList.begin() + n );
                    }
                
                    /* return the n + 1'th root */
                    Real get_root( uint const& n ) const
                    {
                        if( n >= rootList.size() )
                            calculate_n_roots( n+1 );
                
                        return rootList[ n ];
                    }
                
                    /* Fills the rootList with the first n roots. */
                    void calculate_n_roots(uint const& n) const;
                
                    /* Guess the number of terms needed for convergence, given t. */
                    uint guess_maxi( Real const& t ) const;
                
                    /* this is the appropriate definition of the function in gsl. */
                    static Real tan_f (Real x, void *p);
                
                    /* functions for drawTime / p_survival */
                
                    static Real drawT_f (Real t, void *p);
                
                    Real p_survival_table( Real  t, RealVector& psurvTable ) const;
                
                    Real p_survival_i(uint i, Real const& t, RealVector const& table ) const;
                
                    Real p_survival_table_i_v( uint const& i ) const;
                
                    Real p_survival_table_i_nov( uint const& i ) const;
                
                    void createPsurvTable( RealVector& table) const;
                
                
                    /* functions for drawR */
                
                    static Real drawR_f (Real z, void* p);
                
                    Real p_int_r_table(Real const& r, Real const& t, RealVector& table) const;
                
                    Real p_int_r_i(uint i, Real const& r, Real const& t, RealVector& table) const;
                
                    void create_p_int_r_Table( Real const& t, RealVector& table ) const;
                    
                    Real get_p_int_r_Table_i( uint& i, Real const& t, RealVector& table) const
                    {
                        if( i >= table.size() )
                        {
                            calculate_n_roots( i+1 );
                            create_p_int_r_Table(t, table);
                        }
                
                        return table[i];
                    }
                
                    /* Member variables */
                
                    // The diffusion constant and drift velocity
                    Real v;
                    // The reaction constant
                    Real k;
                    Real r0;
                    // The left and right boundary of the domain (sets the l_scale, see below)
                    Real sigma;
                    Real a;
                    // This is the length scale of the system
                    Real l_scale;
                    // This is the time scale of the system.
                    Real t_scale;
                
                    /* vector containing the roots 0f tan_f. */
                    mutable RealVector rootList;
                
                //    static Logger& log_;
                };
                
                }
                #endif // __GREENSFUNCTION1DRADABS_HPP


Top 10 Lines:

     Line      Count

       54          1
       70          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/boost/array.hpp:
                /* The following code declares class array,
                 * an STL container (as wrapper) for arrays of constant size.
                 *
                 * See
                 *      http://www.boost.org/libs/array/
                 * for documentation.
                 *
                 * The original author site is at: http://www.josuttis.com/
                 *
                 * (C) Copyright Nicolai M. Josuttis 2001.
                 *
                 * Distributed under the Boost Software License, Version 1.0. (See
                 * accompanying file LICENSE_1_0.txt or copy at
                 * http://www.boost.org/LICENSE_1_0.txt)
                 *
                 * 14 Apr 2012 - (mtc) Added support for boost::hash
                 * 28 Dec 2010 - (mtc) Added cbegin and cend (and crbegin and crend) for C++Ox compatibility.
                 * 10 Mar 2010 - (mtc) fill method added, matching resolution of the standard library working group.
                 *      See <http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776> or Trac issue #3168
                 *      Eventually, we should remove "assign" which is now a synonym for "fill" (Marshall Clow)
                 * 10 Mar 2010 - added workaround for SUNCC and !STLPort [trac #3893] (Marshall Clow)
                 * 29 Jan 2004 - c_array() added, BOOST_NO_PRIVATE_IN_AGGREGATE removed (Nico Josuttis)
                 * 23 Aug 2002 - fix for Non-MSVC compilers combined with MSVC libraries.
                 * 05 Aug 2001 - minor update (Nico Josuttis)
                 * 20 Jan 2001 - STLport fix (Beman Dawes)
                 * 29 Sep 2000 - Initial Revision (Nico Josuttis)
                 *
                 * Jan 29, 2004
                 */
                #ifndef BOOST_ARRAY_HPP
                #define BOOST_ARRAY_HPP
                
                #include <boost/detail/workaround.hpp>
                
                #if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)  
                # pragma warning(push)  
                # pragma warning(disable:4996) // 'std::equal': Function call with parameters that may be unsafe
                # pragma warning(disable:4510) // boost::array<T,N>' : default constructor could not be generated 
                # pragma warning(disable:4610) // warning C4610: class 'boost::array<T,N>' can never be instantiated - user defined constructor required 
                #endif
                
                #include <cstddef>
                #include <stdexcept>
                #include <boost/assert.hpp>
                #include <boost/swap.hpp>
                
                // Handles broken standard libraries better than <iterator>
                #include <boost/detail/iterator.hpp>
                #include <boost/throw_exception.hpp>
                #include <boost/functional/hash_fwd.hpp>
                #include <algorithm>
                
                // FIXES for broken compilers
                #include <boost/config.hpp>
                
                
                namespace boost {
                
                    template<class T, std::size_t N>
           4 ->     class array {
                      public:
                        T elems[N];    // fixed-size array of elements of type T
                
                      public:
                        // type definitions
                        typedef T              value_type;
                        typedef T*             iterator;
                        typedef const T*       const_iterator;
                        typedef T&             reference;
                        typedef const T&       const_reference;
                        typedef std::size_t    size_type;
                        typedef std::ptrdiff_t difference_type;
                
                        // iterator support
                        iterator        begin()       { return elems; }
                        const_iterator  begin() const { return elems; }
                        const_iterator cbegin() const { return elems; }
                        
                        iterator        end()       { return elems+N; }
                        const_iterator  end() const { return elems+N; }
                        const_iterator cend() const { return elems+N; }
                
                        // reverse iterator support
                #if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_MSVC_STD_ITERATOR) && !defined(BOOST_NO_STD_ITERATOR_TRAITS)
                        typedef std::reverse_iterator<iterator> reverse_iterator;
                        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                #elif defined(_MSC_VER) && (_MSC_VER == 1300) && defined(BOOST_DINKUMWARE_STDLIB) && (BOOST_DINKUMWARE_STDLIB == 310)
                        // workaround for broken reverse_iterator in VC7
                        typedef std::reverse_iterator<std::_Ptrit<value_type, difference_type, iterator,
                                                      reference, iterator, reference> > reverse_iterator;
                        typedef std::reverse_iterator<std::_Ptrit<value_type, difference_type, const_iterator,
                                                      const_reference, iterator, reference> > const_reverse_iterator;
                #elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC) 
                        typedef std::reverse_iterator<iterator, std::random_access_iterator_tag, 
                              value_type, reference, iterator, difference_type> reverse_iterator; 
                        typedef std::reverse_iterator<const_iterator, std::random_access_iterator_tag,
                              value_type, const_reference, const_iterator, difference_type> const_reverse_iterator;
                #else
                        // workaround for broken reverse_iterator implementations
                        typedef std::reverse_iterator<iterator,T> reverse_iterator;
                        typedef std::reverse_iterator<const_iterator,T> const_reverse_iterator;
                #endif
                
                        reverse_iterator rbegin() { return reverse_iterator(end()); }
                        const_reverse_iterator rbegin() const {
                            return const_reverse_iterator(end());
                        }
                        const_reverse_iterator crbegin() const {
                            return const_reverse_iterator(end());
                        }
                
                        reverse_iterator rend() { return reverse_iterator(begin()); }
                        const_reverse_iterator rend() const {
                            return const_reverse_iterator(begin());
                        }
                        const_reverse_iterator crend() const {
                            return const_reverse_iterator(begin());
                        }
                
                        // operator[]
                        reference operator[](size_type i) 
                        { 
                            BOOST_ASSERT_MSG( i < N, "out of range" );
                            return elems[i];
                        }
                        
                        const_reference operator[](size_type i) const 
                        {     
                            BOOST_ASSERT_MSG( i < N, "out of range" );
                            return elems[i]; 
                        }
                
                        // at() with range check
                        reference at(size_type i) { rangecheck(i); return elems[i]; }
                        const_reference at(size_type i) const { rangecheck(i); return elems[i]; }
                    
                        // front() and back()
                        reference front() 
                        { 
                            return elems[0]; 
                        }
                        
                        const_reference front() const 
                        {
                            return elems[0];
                        }
                        
                        reference back() 
                        { 
                            return elems[N-1]; 
                        }
                        
                        const_reference back() const 
                        { 
                            return elems[N-1]; 
                        }
                
                        // size is constant
                        static size_type size() { return N; }
                        static bool empty() { return false; }
                        static size_type max_size() { return N; }
                        enum { static_size = N };
                
                        // swap (note: linear complexity)
                        void swap (array<T,N>& y) {
                            for (size_type i = 0; i < N; ++i)
                                boost::swap(elems[i],y.elems[i]);
                        }
                
                        // direct access to data (read-only)
                        const T* data() const { return elems; }
                        T* data() { return elems; }
                
                        // use array as C array (direct read/write access to data)
                        T* c_array() { return elems; }
                
                        // assignment with type conversion
                        template <typename T2>
                        array<T,N>& operator= (const array<T2,N>& rhs) {
                            std::copy(rhs.begin(),rhs.end(), begin());
                            return *this;
                        }
                
                        // assign one value to all elements
                        void assign (const T& value) { fill ( value ); }    // A synonym for fill
                        void fill   (const T& value)
                        {
                            std::fill_n(begin(),size(),value);
                        }
                
                        // check range (may be private because it is static)
                        static void rangecheck (size_type i) {
                            if (i >= size()) {
                                std::out_of_range e("array<>: index out of range");
                                boost::throw_exception(e);
                            }
                        }
                
                    };
                
                #if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
                    template< class T >
                    class array< T, 0 > {
                
                      public:
                        // type definitions
                        typedef T              value_type;
                        typedef T*             iterator;
                        typedef const T*       const_iterator;
                        typedef T&             reference;
                        typedef const T&       const_reference;
                        typedef std::size_t    size_type;
                        typedef std::ptrdiff_t difference_type;
                
                        // iterator support
                        iterator        begin()       { return       iterator( reinterpret_cast<       T * >( this ) ); }
                        const_iterator  begin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }
                        const_iterator cbegin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }
                
                        iterator        end()       { return  begin(); }
                        const_iterator  end() const { return  begin(); }
                        const_iterator cend() const { return cbegin(); }
                
                        // reverse iterator support
                #if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_MSVC_STD_ITERATOR) && !defined(BOOST_NO_STD_ITERATOR_TRAITS)
                        typedef std::reverse_iterator<iterator> reverse_iterator;
                        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                #elif defined(_MSC_VER) && (_MSC_VER == 1300) && defined(BOOST_DINKUMWARE_STDLIB) && (BOOST_DINKUMWARE_STDLIB == 310)
                        // workaround for broken reverse_iterator in VC7
                        typedef std::reverse_iterator<std::_Ptrit<value_type, difference_type, iterator,
                                                      reference, iterator, reference> > reverse_iterator;
                        typedef std::reverse_iterator<std::_Ptrit<value_type, difference_type, const_iterator,
                                                      const_reference, iterator, reference> > const_reverse_iterator;
                #elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC) 
                        typedef std::reverse_iterator<iterator, std::random_access_iterator_tag, 
                              value_type, reference, iterator, difference_type> reverse_iterator; 
                        typedef std::reverse_iterator<const_iterator, std::random_access_iterator_tag,
                              value_type, const_reference, const_iterator, difference_type> const_reverse_iterator;
                #else
                        // workaround for broken reverse_iterator implementations
                        typedef std::reverse_iterator<iterator,T> reverse_iterator;
                        typedef std::reverse_iterator<const_iterator,T> const_reverse_iterator;
                #endif
                
                        reverse_iterator rbegin() { return reverse_iterator(end()); }
                        const_reverse_iterator rbegin() const {
                            return const_reverse_iterator(end());
                        }
                        const_reverse_iterator crbegin() const {
                            return const_reverse_iterator(end());
                        }
                
                        reverse_iterator rend() { return reverse_iterator(begin()); }
                        const_reverse_iterator rend() const {
                            return const_reverse_iterator(begin());
                        }
                        const_reverse_iterator crend() const {
                            return const_reverse_iterator(begin());
                        }
                
                        // operator[]
                        reference operator[](size_type /*i*/)
                        {
                            return failed_rangecheck();
                        }
                
                        const_reference operator[](size_type /*i*/) const
                        {
                            return failed_rangecheck();
                        }
                
                        // at() with range check
                        reference at(size_type /*i*/)               {   return failed_rangecheck(); }
                        const_reference at(size_type /*i*/) const   {   return failed_rangecheck(); }
                
                        // front() and back()
                        reference front()
                        {
                            return failed_rangecheck();
                        }
                
                        const_reference front() const
                        {
                            return failed_rangecheck();
                        }
                
                        reference back()
                        {
                            return failed_rangecheck();
                        }
                
                        const_reference back() const
                        {
                            return failed_rangecheck();
                        }
                
                        // size is constant
                        static size_type size() { return 0; }
                        static bool empty() { return true; }
                        static size_type max_size() { return 0; }
                        enum { static_size = 0 };
                
                        void swap (array<T,0>& /*y*/) {
                        }
                
                        // direct access to data (read-only)
                        const T* data() const { return 0; }
                        T* data() { return 0; }
                
                        // use array as C array (direct read/write access to data)
                        T* c_array() { return 0; }
                
                        // assignment with type conversion
                        template <typename T2>
                        array<T,0>& operator= (const array<T2,0>& ) {
                            return *this;
                        }
                
                        // assign one value to all elements
                        void assign (const T& value) { fill ( value ); }
                        void fill   (const T& ) {}
                        
                        // check range (may be private because it is static)
                        static reference failed_rangecheck () {
                                std::out_of_range e("attempt to access element of an empty array");
                                boost::throw_exception(e);
                #if defined(BOOST_NO_EXCEPTIONS) || (!defined(BOOST_MSVC) && !defined(__PATHSCALE__))
                                //
                                // We need to return something here to keep
                                // some compilers happy: however we will never
                                // actually get here....
                                //
                                static T placeholder;
                                return placeholder;
                #endif
                            }
                    };
                #endif
                
                    // comparisons
                    template<class T, std::size_t N>
                    bool operator== (const array<T,N>& x, const array<T,N>& y) {
                        return std::equal(x.begin(), x.end(), y.begin());
                    }
                    template<class T, std::size_t N>
                    bool operator< (const array<T,N>& x, const array<T,N>& y) {
                        return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());
                    }
                    template<class T, std::size_t N>
                    bool operator!= (const array<T,N>& x, const array<T,N>& y) {
                        return !(x==y);
                    }
                    template<class T, std::size_t N>
                    bool operator> (const array<T,N>& x, const array<T,N>& y) {
                        return y<x;
                    }
                    template<class T, std::size_t N>
                    bool operator<= (const array<T,N>& x, const array<T,N>& y) {
                        return !(y<x);
                    }
                    template<class T, std::size_t N>
                    bool operator>= (const array<T,N>& x, const array<T,N>& y) {
                        return !(x<y);
                    }
                
                    // global swap()
                    template<class T, std::size_t N>
                    inline void swap (array<T,N>& x, array<T,N>& y) {
                        x.swap(y);
                    }
                
                #if defined(__SUNPRO_CC)
                //  Trac ticket #4757; the Sun Solaris compiler can't handle
                //  syntax like 'T(&get_c_array(boost::array<T,N>& arg))[N]'
                //  
                //  We can't just use this for all compilers, because the 
                //      borland compilers can't handle this form. 
                    namespace detail {
                       template <typename T, std::size_t N> struct c_array
                       {
                           typedef T type[N];
                       };
                    }
                    
                   // Specific for boost::array: simply returns its elems data member.
                   template <typename T, std::size_t N>
                   typename detail::c_array<T,N>::type& get_c_array(boost::array<T,N>& arg)
                   {
                       return arg.elems;
                   }
                
                   // Specific for boost::array: simply returns its elems data member.
                   template <typename T, std::size_t N>
                   typename const detail::c_array<T,N>::type& get_c_array(const boost::array<T,N>& arg)
                   {
                       return arg.elems;
                   }
                #else
                // Specific for boost::array: simply returns its elems data member.
                    template <typename T, std::size_t N>
                    T(&get_c_array(boost::array<T,N>& arg))[N]
                    {
                        return arg.elems;
                    }
                    
                    // Const version.
                    template <typename T, std::size_t N>
                    const T(&get_c_array(const boost::array<T,N>& arg))[N]
                    {
                        return arg.elems;
                    }
                #endif
                    
                #if 0
                    // Overload for std::array, assuming that std::array will have
                    // explicit conversion functions as discussed at the WG21 meeting
                    // in Summit, March 2009.
                    template <typename T, std::size_t N>
                    T(&get_c_array(std::array<T,N>& arg))[N]
                    {
                        return static_cast<T(&)[N]>(arg);
                    }
                    
                    // Const version.
                    template <typename T, std::size_t N>
                    const T(&get_c_array(const std::array<T,N>& arg))[N]
                    {
                        return static_cast<T(&)[N]>(arg);
                    }
                #endif
                
                
                    template<class T, std::size_t N>
                    std::size_t hash_value(const array<T,N>& arr)
                    {
                        return boost::hash_range(arr.begin(), arr.end());
                    }
                
                } /* namespace boost */
                
                
                #if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)  
                # pragma warning(pop)  
                #endif 
                
                #endif /*BOOST_ARRAY_HPP*/


Top 10 Lines:

     Line      Count

       60          4

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        4   Total number of line executions
     4.00   Average executions per line


*** File /usr/include/boost/random/uniform_real_distribution.hpp:
                /* boost random/uniform_real_distribution.hpp header file
                 *
                 * Copyright Jens Maurer 2000-2001
                 * Copyright Steven Watanabe 2011
                 * Distributed under the Boost Software License, Version 1.0. (See
                 * accompanying file LICENSE_1_0.txt or copy at
                 * http://www.boost.org/LICENSE_1_0.txt)
                 *
                 * See http://www.boost.org for most recent version including documentation.
                 *
                 * $Id: uniform_real_distribution.hpp 71018 2011-04-05 21:27:52Z steven_watanabe $
                 *
                 */
                
                #ifndef BOOST_RANDOM_UNIFORM_REAL_DISTRIBUTION_HPP
                #define BOOST_RANDOM_UNIFORM_REAL_DISTRIBUTION_HPP
                
                #include <iosfwd>
                #include <ios>
                #include <istream>
                #include <boost/assert.hpp>
                #include <boost/config.hpp>
                #include <boost/random/detail/config.hpp>
                #include <boost/random/detail/operators.hpp>
                #include <boost/random/detail/signed_unsigned_tools.hpp>
                #include <boost/type_traits/is_integral.hpp>
                
                namespace boost {
                namespace random {
                namespace detail {
                
                template<class Engine, class T>
                T generate_uniform_real(
                    Engine& eng, T min_value, T max_value,
                    boost::mpl::false_  /** is_integral<Engine::result_type> */)
                {
                    for(;;) {
                        typedef T result_type;
                        typedef typename Engine::result_type base_result;
                        result_type numerator = static_cast<T>(eng() - (eng.min)());
                        result_type divisor = static_cast<T>((eng.max)() - (eng.min)());
                        BOOST_ASSERT(divisor > 0);
                        BOOST_ASSERT(numerator >= 0 && numerator <= divisor);
                        T result = numerator / divisor * (max_value - min_value) + min_value;
                        if(result < max_value) return result;
                    }
                }
                
                template<class Engine, class T>
       24000 -> T generate_uniform_real(
                    Engine& eng, T min_value, T max_value,
                    boost::mpl::true_  /** is_integral<Engine::result_type> */)
                {
                    for(;;) {
                        typedef T result_type;
                        typedef typename Engine::result_type base_result;
                        result_type numerator = static_cast<T>(subtract<base_result>()(eng(), (eng.min)()));
                        result_type divisor = static_cast<T>(subtract<base_result>()((eng.max)(), (eng.min)())) + 1;
                        BOOST_ASSERT(divisor > 0);
                        BOOST_ASSERT(numerator >= 0 && numerator <= divisor);
                        T result = numerator / divisor * (max_value - min_value) + min_value;
                        if(result < max_value) return result;
                    }
                }
                
                template<class Engine, class T>
       24000 -> inline T generate_uniform_real(Engine& eng, T min_value, T max_value)
                {
                    typedef typename Engine::result_type base_result;
                    return generate_uniform_real(eng, min_value, max_value,
                        boost::is_integral<base_result>());
                }
                
                }
                
                /**
                 * The class template uniform_real_distribution models a \random_distribution.
                 * On each invocation, it returns a random floating-point value uniformly
                 * distributed in the range [min..max).
                 */
                template<class RealType = double>
                class uniform_real_distribution
                {
                public:
                    typedef RealType input_type;
                    typedef RealType result_type;
                
                    class param_type
                    {
                    public:
                
                        typedef uniform_real_distribution distribution_type;
                
                        /**
                         * Constructs the parameters of a uniform_real_distribution.
                         *
                         * Requires min <= max
                         */
                        explicit param_type(RealType min_arg = RealType(0.0),
                                            RealType max_arg = RealType(1.0))
                          : _min(min_arg), _max(max_arg)
                        {
                            BOOST_ASSERT(_min <= _max);
                        }
                
                        /** Returns the minimum value of the distribution. */
                        RealType a() const { return _min; }
                        /** Returns the maximum value of the distribution. */
                        RealType b() const { return _max; }
                
                        /** Writes the parameters to a @c std::ostream. */
                        BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, param_type, parm)
                        {
                            os << parm._min << " " << parm._max;
                            return os;
                        }
                
                        /** Reads the parameters from a @c std::istream. */
                        BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, param_type, parm)
                        {
                            RealType min_in, max_in;
                            if(is >> min_in >> std::ws >> max_in) {
                                if(min_in <= max_in) {
                                    parm._min = min_in;
                                    parm._max = max_in;
                                } else {
                                    is.setstate(std::ios_base::failbit);
                                }
                            }
                            return is;
                        }
                
                        /** Returns true if the two sets of parameters are equal. */
                        BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(param_type, lhs, rhs)
                        { return lhs._min == rhs._min && lhs._max == rhs._max; }
                
                        /** Returns true if the two sets of parameters are different. */
                        BOOST_RANDOM_DETAIL_INEQUALITY_OPERATOR(param_type)
                
                    private:
                
                        RealType _min;
                        RealType _max;
                    };
                
                    /**
                     * Constructs a uniform_real_distribution. @c min and @c max are
                     * the parameters of the distribution.
                     *
                     * Requires: min <= max
                     */
          12 ->     explicit uniform_real_distribution(
                        RealType min_arg = RealType(0.0),
                        RealType max_arg = RealType(1.0))
                      : _min(min_arg), _max(max_arg)
                    {
                        BOOST_ASSERT(min_arg <= max_arg);
                    }
                    /** Constructs a uniform_real_distribution from its parameters. */
                    explicit uniform_real_distribution(const param_type& parm)
                      : _min(parm.a()), _max(parm.b()) {}
                
                    /**  Returns the minimum value of the distribution */
                    RealType min BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _min; }
                    /**  Returns the maximum value of the distribution */
                    RealType max BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _max; }
                
                    /**  Returns the minimum value of the distribution */
                    RealType a() const { return _min; }
                    /**  Returns the maximum value of the distribution */
                    RealType b() const { return _max; }
                
                    /** Returns the parameters of the distribution. */
                    param_type param() const { return param_type(_min, _max); }
                    /** Sets the parameters of the distribution. */
                    void param(const param_type& parm)
                    {
                        _min = parm.a();
                        _max = parm.b();
                    }
                
                    /**
                     * Effects: Subsequent uses of the distribution do not depend
                     * on values produced by any engine prior to invoking reset.
                     */
                    void reset() { }
                
                    /** Returns a value uniformly distributed in the range [min, max). */
                    template<class Engine>
       24000 ->     result_type operator()(Engine& eng) const
                    { return detail::generate_uniform_real(eng, _min, _max); }
                
                    /**
                     * Returns a value uniformly distributed in the range
                     * [param.a(), param.b()).
                     */
                    template<class Engine>
                    result_type operator()(Engine& eng, const param_type& parm) const
                    { return detail::generate_uniform_real(eng, parm.a(), parm.b()); }
                
                    /** Writes the distribution to a @c std::ostream. */
                    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, uniform_real_distribution, ud)
                    {
                        os << ud.param();
                        return os;
                    }
                
                    /** Reads the distribution from a @c std::istream. */
                    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, uniform_real_distribution, ud)
                    {
                        param_type parm;
                        if(is >> parm) {
                            ud.param(parm);
                        }
                        return is;
                    }
                
                    /**
                     * Returns true if the two distributions will produce identical sequences
                     * of values given equal generators.
                     */
                    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(uniform_real_distribution, lhs, rhs)
                    { return lhs._min == rhs._min && lhs._max == rhs._max; }
                    
                    /**
                     * Returns true if the two distributions may produce different sequences
                     * of values given equal generators.
                     */
                    BOOST_RANDOM_DETAIL_INEQUALITY_OPERATOR(uniform_real_distribution)
                
                private:
                    RealType _min;
                    RealType _max;
                };
                
                } // namespace random
                } // namespace boost
                
                #endif // BOOST_RANDOM_UNIFORM_INT_HPP


Top 10 Lines:

     Line      Count

       50      24000
       67      24000
      190      24000
      152         12

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

    72012   Total number of line executions
 18003.00   Average executions per line


*** File /home/niina/greens_functions/main.cpp:
                #include "GreensFunction1DAbsAbs.hpp"
                #include "GreensFunction1DAbsSinkAbs.hpp"
                #include "GreensFunction1DRadAbs.hpp"
                #include "GreensFunction2DAbsSym.hpp"
                #include "GreensFunction2DRadAbs.hpp"
                #include "GreensFunction3D.hpp"
                #include "GreensFunction3DAbs.hpp"
                #include "GreensFunction3DSym.hpp"
                #include "GreensFunction3DAbsSym.hpp"
                #include "GreensFunction3DRadAbs.hpp"
                #include "GreensFunction3DRadInf.hpp"
                #include <boost/random.hpp>
                #include <iostream>
                
                //using namespace greens_functions;
                
                template <typename T_>
          10 -> void test_func(T_ gf, std::string const name)
                {
                    Real const t(1.0);
                    boost::random::mt19937 rng(0);
                    boost::random::uniform_real_distribution<Real> rand(0.0, 1.0);
                
                    std::cout << name << std::endl;
                    Real bufT, bufR;
                    for (int i=0; i < 1000; i++)
                    {
                	bufT = gf.drawTime(rand(rng));
                	bufR = gf.drawR(rand(rng), t);
                    }
                
                
                //    std::cout << "drawTime: " << gf.drawTime(rand(rng)) << std::endl;
                //    std::cout << "drawR: " << gf.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                }
                
                template <typename T_>
           2 -> void test_theta(T_ gf, std::string const name)
                {
                    Real const t(1.0);
                    Real const r(5e-1);
                    boost::random::mt19937 rng(0);
                    boost::random::uniform_real_distribution<Real> rand(0.0, 1.0);
                
                    std::cout << name << std::endl;
                
                    Real bufT;
                    int eventType;
                    for (int i=0; i < 1000; i++)
                    {
                	bufT = gf.drawTheta(rand(rng), r, t);
                	eventType = gf.drawEventType(rand(rng), t);
                    }
                
                    std::cout << std::endl;
                }
                
                int main()
       ##### -> {
                    Real const D(1.0);
                    Real const a(1.e1);
                    Real const r0(1.0);
                    Real const k(0.5);
                    Real const rsink(0.5);
                    Real const sigma(1.e-1);
                
                    test_func(greens_functions::GreensFunction1DAbsAbs(D, r0, sigma, a), "GreensFunction1DAbsAbs"); //drawEventType
                    test_func(greens_functions::GreensFunction1DAbsSinkAbs(D, k, r0, rsink, sigma, a), "GreensFunction1DAbsSinkAbs"); //drawEventType
                    test_func(greens_functions::GreensFunction1DRadAbs(D, k, r0, sigma, a), "GreensFunction1DRadAbs"); //drawEventType
                    test_func(greens_functions::GreensFunction2DAbsSym(D, a), "GreensFunction2DAbsSym"); //
                    test_func(greens_functions::GreensFunction2DRadAbs(D, k, r0, sigma, a), "GreensFunction2DRadAbs"); //drawEventType, drawTheta
                    test_func(greens_functions::GreensFunction3D(D, a), "GreensFunction3D"); //drawTheta
                    test_func(greens_functions::GreensFunction3DAbs(D, r0, a), "GreensFunction3DAbs"); //drawEventType drawTheta
                    test_func(greens_functions::GreensFunction3DAbsSym(D, a), "GreensFunction3DAbsSym"); //
                    test_func(greens_functions::GreensFunction3DRadAbs(D, k, r0, sigma, a), "GreensFunction3DRadAbs"); //drawEventType, drawTheta
                    test_func(greens_functions::GreensFunction3DRadInf(D, k, r0, sigma), "GreensFunction3DRadInf"); //drawTheta
                
                    test_theta(greens_functions::GreensFunction3DRadAbs(D, k, r0, sigma, a), "GreensFunction3DRadAbs"); //drawEventType, drawTheta
                    test_theta(greens_functions::GreensFunction2DRadAbs(D, k, r0, sigma, a), "GreensFunction2DRadAbs"); //drawEventType, drawTheta
                
                /*
                    boost::random::mt19937 rng(0);
                    boost::random::uniform_real_distribution<Real> rand(0.0, 1.0);
                
                    greens_functions::GreensFunction1DAbsAbs gf_1DAbsAbs(D, r0, sigma, a);
                    greens_functions::GreensFunction1DAbsSinkAbs gf_1DAbsSinkAbs(D, k, r0, rsink, sigma, a);
                    greens_functions::GreensFunction1DRadAbs gf_1DRadAbs(D, k, r0, sigma, a);
                    greens_functions::GreensFunction2DAbsSym gf_2DAbsSym(D, a);
                    greens_functions::GreensFunction2DRadAbs gf_2DRadAbs(D, k, r0, sigma, a);
                    greens_functions::GreensFunction3D gf_3D(D, a);
                    greens_functions::GreensFunction3DAbs gf_3DAbs(D, r0, a);
                    greens_functions::GreensFunction3DSym gf_3DSym(D);
                    greens_functions::GreensFunction3DAbsSym gf_3DAbsSym(D, a);
                    greens_functions::GreensFunction3DRadAbs gf_3DRadAbs(D, k, r0, sigma, a);
                    greens_functions::GreensFunction3DRadInf gf_3DRadInf(D, k, r0, sigma);
                
                    Real const t(1.0);
                    std::cout << "1DAbsAbs" << std::endl;
                    std::cout << "drawTime: " << gf_1DAbsAbs.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_1DAbsAbs.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "1DAbsSinkAbs" << std::endl;
                    std::cout << "drawTime: " << gf_1DAbsSinkAbs.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_1DAbsSinkAbs.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "1DRadAbs" << std::endl;
                    std::cout << "drawTime: " << gf_1DRadAbs.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_1DRadAbs.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "2DAbsSym" << std::endl;
                    std::cout << "drawTime: " << gf_2DAbsSym.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_2DAbsSym.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "2DRadAbs" << std::endl;
                    std::cout << "drawTime: " << gf_2DRadAbs.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_2DRadAbs.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "3D" << std::endl;
                    std::cout << "drawTime: " << gf_3D.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_3D.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "3DAbs" << std::endl;
                    std::cout << "drawTime: " << gf_3DAbs.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_3DAbs.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "3DSym" << std::endl;
                    std::cout << "drawTime: " << gf_3DSym.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_3DSym.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "3DAbsSym" << std::endl;
                    std::cout << "drawTime: " << gf_3DAbsSym.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_3DAbsSym.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "3DRadAbs" << std::endl;
                    std::cout << "drawTime: " << gf_3DRadAbs.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_3DRadAbs.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "3DRadInf" << std::endl;
                    std::cout << "drawTime: " << gf_3DRadInf.drawTime(rand(rng)) << std::endl;
                    std::cout << "drawR: " << gf_3DRadInf.drawR(rand(rng), t) << std::endl;
                    std::cout << std::endl;
                    std::cout << "end" << std::endl;
                */
                    return 0;
           2 -> }


Top 10 Lines:

     Line      Count

       18         10
       39          2
      146          2

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

       14   Total number of line executions
     3.50   Average executions per line
